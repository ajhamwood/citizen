let Wrap : U -> U                       = \A. (W : U) -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A           = \a W w. w a;
let unwrap : {A} -> Wrap A -> A         = \w. w _ (\x. x);

let Nat : U                             = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                          = \N s z. z;
let suc : Nat -> Nat                    = \n N s z. s (n N s z);

let Vec : {n} -> U -> U
    = \{n} A. (V : Nat -> U) -> V zero -> ({m : Nat} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A
    = \V n c. n;
let cons : {n A} -> A -> Vec {n} A -> Vec {suc n} A
    = \a as V n c. c a (as V n c);



let Bit : U                             = {B} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let not : Bit -> Bit                    = \b i o. b o i;

let Maybe : U -> U                      = \A. {M} -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A            = \n j. n;
let just : {A} -> A -> Maybe A          = \a n j. j a;

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeFunctor : Functor Maybe
    = \f. f (\fn ma n j. ma n (\a. j (fn a)));

maybeFunctor (\map. map not (just O))



let Bit : U                             = {B} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let Nat : U                             = {N} -> (N -> N) -> N -> N;
let zero : Nat                          = \s z. z;
let suc : Nat -> Nat                    = \n s z. s (n s z);

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> LTree {zero} A
    = \a b T l n. l a b;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);
-- eliminators

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let ltreeFunctor : Functor LTree
    = \f. f (\fn ta T l n. ta T (\a b. l (fn a) (fn b)) n);

let mapltree : {A B n} -> (A -> B) -> LTree {n} A -> LTree {n} B
    = \{A}{B} fn ltree. ltree (\n. LTree {n} B) (\a b. leaf (fn a) (fn b)) node;

let someltree : LTree Bit
    = node (node (leaf O I) (leaf I O)) (node (leaf I O) (leaf O I));
mapltree not someltree



let Bit : U                             = {B : U} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let Pair : U -> U -> U                  = \A B. {P} -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B  = \a b p. p a b;
let fst : {A B} -> Pair A B -> A        = \s. s (\a b. a);
let snd : {A B} -> Pair A B -> B        = \s. s (\a b. b);

let Nat : U                             = {N} -> (N -> N) -> N -> N;
let zero : Nat                          = \s z. z;
let suc : Nat -> Nat                    = \n s z. s (n s z);

let mul : Nat -> Nat -> Nat = \a b s z. a (b s) z;
let eqz : Nat -> Bit = \n. n (\z i o. o) (\i o. i);
let pred : Nat -> Nat =
    \n. snd {Nat} (n (\p. pair (suc (fst p)) (fst p)) (pair zero zero));

let fold : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat}
        (n {Pair Nat A} (\p. pair (suc (fst p)) (p reducer)) (pair zero base));

let fact : Nat -> Nat
    = \n. fold {Nat} (\k acc. mul acc (suc k)) (suc zero) n;

fact (suc (suc (suc zero)))



-- Dependently Typed Folds for Nested Data Types, Peng Fu and Peter Selinger
let Bush : {n} -> U -> U
    = \{n} A. (B : Nat -> U) -> (A -> B zero) -> ({n} -> B (suc n)) ->
        ({n} -> B n -> B (suc (suc n)) -> B (suc n)) -> B n;
let bbase : {A} -> A -> Bush {zero} A
    = \a B b n c. b a;
let bnil : {n A} -> Bush {suc n} A
    = \B b n c. n;
let bcons : {n A} -> Bush {n} A -> Bush {suc (suc n)} A -> Bush {suc n} A
    = \x xs B b n c. c (x B b n c) (xs B b n c);

let foldbush : {A} -> (B : Nat -> U) -> (A -> B zero) ->
               ({n} -> B (suc n)) -> ({n} -> B n -> B (suc (suc n)) -> B (suc n)) ->
               {n} -> Bush {n} A -> B n
    = \B b n c bush. bush B b n c;

let mapbush : {A B n} -> (A -> B) -> Bush {n} A -> Bush {n} B
    = \{A}{B} fn. foldbush {A} (\n. Bush {n} B) (\x. bbase (fn x)) bnil bcons;

-- [ O,
--   [ I, [ I ] ],
--   [ [ O ] ] ]
let somebush : Bush Bit
    = bcons (bbase O) (bcons
            (bcons (bbase I) (bcons
                   (bcons (bbase I) bnil)
                   bnil)) (bcons
            (bcons (bcons (bbase O) bnil)
                   bnil)
            bnil));
            
mapbush not somebush



let Nonempty : U -> U                   = \A. {N} -> (A -> N) -> (A -> N -> N) -> N;
let sing : {A} -> A -> Nonempty A       = \a s c. s a;
let cons : {A} -> A -> Nonempty A -> Nonempty A = \a as s c. c a (as s c);

let Monoid : U -> U                     = \A. {M} -> (neut : M) -> (comb : A -> M -> M) -> M;
let neut : {A} -> Monoid A              = \n c. n;
let comb : {A} -> A -> Monoid A -> Monoid A = \a as n c. c a (as n c);

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeFunctor : Functor Maybe
    = \F. F (\fn ma n j. ma n (\a. j (fn a)));

let Foldable : (U -> U) -> U
    = \(F : U -> U). {T}{super : Functor F}{A W} ->
                     ((foldmap : {MonW : Monoid W} -> (A -> W) -> F A -> W) -> F T) -> F T;
-- let fold : {W}{F : U -> U}{FoldF : Foldable F}{MonW : Monoid W} -> F W -> W
--     = foldmap (\x. x);

let maybeFoldable : Foldable Maybe
    = \{super=super}{A=A}{W=W} f. f (\{MonW=maybeMonoid} fn ma. ma {Maybe A} nothing (\x. just (fn x)));
maybeFoldable {maybeFunctor} (\foldmap. foldmap not (just O))


let Monoid : U -> U
    = \M. ({A} -> (neut : M) -> (comb : A -> M -> M) -> M) -> M;
let maybeMonoid : {A} -> Monoid (Maybe A)
    = \{A=A} f. f {A} nothing (\a _. just a);

-- maybeMonoid {Bit} (\n c. n)
maybeMonoid {Bit} (\n c. c I _)



let Nat : U                             = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                          = \N s z. z;
let suc : Nat -> Nat                    = \n N s z. s (n N s z);

let DNat : Nat -> U                     = \n. (DN : Nat -> U) -> ({m} -> DN m -> DN (suc m)) -> DN zero -> DN n;
let dz : DNat zero                      = \DN s z. z;
let dsuc : {m : Nat} -> DNat m -> DNat (suc m) = \n DN s z. s (n DN s z);

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> LTree {zero} A
    = \a b T l n. l a b;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);

let initWord : {n} -> DNat n -> LTree {n} Bit
    = \dn. dn (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O O);
initWord (dsuc (dsuc dz))



let bitAdd : Bit -> Bit -> Bit -> Pair Bit Bit
    = \a b c. pair (carry a b c) (sum a b c);

let addWithCarry : {n} -> LTree {n} Bit -> LTree {n} Bit -> Pair Bit (LTree {n} Bit)
    = \ta tb. x;
let word0 = leaf O I;
let word1 = leaf I I;
addWithCarry word0 word1



let head : {A n} -> Vec {suc n} A -> A  = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);
-- tail (cons I (cons O nil))

let getBit : {n} -> LTree {n} Bit -> Vec {suc n} Bit -> Bit
    = \{n} ltree vec. fst ((tail vec) (\k. Pair Bit (LTree {sub n k} Bit))
        (pair (head vec) ltree) (\{k} bit acc. (snd acc) _
            (\a b. pair (bit _ a b) (initWord dz))
            (\ta tb. pair bit (bit _ ta tb))));
let addr : Vec {suc zero} Bit
    = cons O nil;
let word0 : LTree {zero} Bit
    = leaf O I;
getBit word0 addr


(\n. addr (\k. (sub (suc n) k) _ (\_. LTree {sub n k} Bit) Bit)
    word0 (\{k} bit acc. acc ((sub (suc n) k) _ (\_. LTree {sub n k} Bit) Bit) (\a b. bit Bit a b) (\ta tb. bit (Tree {sub n k} Bit) ta tb))) zero



let LC : U = {R} -> (L : (R -> R) -> R) -> (A : R -> R -> R) -> R;
let id : LC = \l a. l (\x. x);
let comp : LC = \l a. l (\g. l (\f. l (\x. a g (a f x))));
let delta : LC = \l a. l (\x. a x x);
let omega : LC = \l a. a (l (\x. a x x)) (l (\x. a x x));
let z : LC = \l a. l (\s. l (\z. a s z));
let s : LC = \l a. l (\n. l (\s. l (\z. a s (a (a n s) z))));



let Either : U -> U -> U                = \A B. (E : U) -> (A -> E) -> (B -> E) -> E;
let left : {A B} -> A -> Either A B     = \a E l r. l a;
let right : {A B} -> B -> Either A B    = \b E l r. r b;
-- let resolve : {A B}{C : Either A B -> U} -> ((a : A) -> C (left a)) -> ((b : B) -> C (right b)) ->
--               (e : Either A B) -> C e
--     = \{C=C} f g e. e (C e) f g;

let Void : U                            = (V : U) -> V;
let absurd : {A} -> Void -> A           = \v. _;
let neg : U -> U                        = \P. P -> Void;
let Dec : U -> U                        = \P. Either P (neg P);
let Decidable : {A B} -> (A -> B -> U) -> U = \{A}{B} p. (x : A) -> (y : B) -> Dec (p x y);

let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A
    = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A
    = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);
let divine : {A} -> LTree {zero} A -> A
    = \{A} t. t (\_. A) (\a. a) _;
-- divine (leaf O)
-- lbranch (node (leaf O) (leaf I))

let getBit : {n} -> LTree {n} Bit -> Vec {n} Bit -> Bit
    = \{n} ltree vec. divine (vec (\k. LTree {sub n k} Bit) ltree
        (\{k} bit acc. bit (LTree {sub n k} Bit) (lbranch {Bit}{sub n k} acc) (rbranch {Bit}{sub n k} acc)));
getBit word0 addr



-- Bit addressing

let getBit : {n} -> LTree {n} Bit -> Vec {n} Bit -> LTree {zero} Bit
    = \{n} ltree vec. snd (vec (\k. Pair Nat (LTree {sub n k} Bit)) (pair n ltree)
        (\{k} bit acc. pair (pred (fst acc))
            (bit (LTree {sub n k} Bit)
                ((snd acc) (\_. LTree {sub n k} Bit) _ (\ta tb. ta))
                ((snd acc) (\_. LTree {sub n k} Bit) _ (\ta tb. tb)))));
-- bit (Pair Nat (LTree {fst acc} Bit)) (lbranch {Bit}{fst acc} (snd acc)) (rbranch {Bit}{fst acc} (snd acc))

let addr : Vec {suc zero} Bit
    = cons O nil;
let word0 : LTree {suc zero} Bit
    = node (leaf O) (leaf O);
getBit word0 addr



let Cont : U -> U -> U                  = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W = \c f. c _ (\k. k f);
let reset : {W} -> Cont W W -> W        = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));

let add : Nat -> Nat -> Nat             = \a b N s z. a N s (b N s z);
let addcps : Nat -> Nat -> Cont Nat Nat = \a b. cont (\k. k (add a b));
let test : Nat -> Nat -> Cont Nat Nat   = \a b. cont (\k. run (addcps a b) (\v. run (addcps a v) k));
run (test (suc (suc zero)) (suc zero)) (\x. x)


-- Monads

let Monad : (U -> U) -> U
    = \(M : U -> U). {T} -> ((return : {A} -> A -> M A) ->
                     (bind : {A B} -> M A -> (A -> M B) -> M B) -> M T) -> M T;
let contMonad : {W} -> Monad (Cont W)
    = \M. M (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));


let List : U -> U                       = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                = \L n c. n;
let cons : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let concat : {A} -> List A -> List A -> List A      = \{A} la lb. la (List A) lb cons;
let listFunctor : Functor List                      = \F. F (\fn la L n c. la L n (\a as. c (fn a) as));

let mapM : {A B}{M : U -> U}{monad : Monad M} -> (A -> M B) -> List A -> M (List B)
    = (\{A}{B}{M}{monad} f as. monad
        (\return bind. as (M (List B)) (return nil)
            (\a r. bind {B}{List B} (f a) (\x. bind {List B}{List B} r (\xs. return (cons x xs))))));
run {List Bit} (mapM {monad=contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)



let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
                     (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;
let appFunctor : {X} -> App X -> Functor X
    = \app F. F (\{A}{B} fn fa. app (\pure ap. ap {A}{B} (pure fn) fa));
let listApp : App List                              = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (listFunctor (\map. map f xs)) bs));
let appComp : {F G : U -> U} -> App F -> App G -> App (\X. G (F X))
    = \{F}{G} appF appG A. A
        (\{X} x. appG {F X} (\pureG apG. pureG (appF {X} (\pureF apF. pureF x))))
        (\f x. (appFunctor appF) (\map. appG (\{X}{Y} pureG apG. map {X}{Y} apG (appF {X} (\pureF apF. apF {X}{Y})) f) s));
(appComp listApp listApp) (\pure ap. ap
    (cons (cons not nil) nil)
    (cons (cons O (cons I nil)) (cons (cons I nil) nil)))

let Trav : (U -> U) -> U
    = \(F : U -> U). {T} -> ((traverse : {G : U -> U}{A B}{app : App G} -> (A -> G B) -> F A -> G (F B)) -> F T) -> F T;


-- Finite sets

let Fin : {n} -> U                                  = \{n}. (F : Nat -> U) -> ({m} -> F m -> F (suc m)) -> ({m} -> F (suc m)) -> F n;
let fz : {n} -> Fin {suc n}                         = \F s z. z;
let fs : {n} -> Fin {n} -> Fin {suc n}              = \f F s z. s (f F s z);

let lookup : {A n} -> Fin {n} -> Vec {n} A -> A
--    = \{A} f v. v (\_. A) _ (\a as. f _ (\_. as) a);
    = \{A}{m} f V n c. snd {Nat} (f (\_. Pair Nat A) (\p. pair (suc (fst p)) (p c)) (pair zero n));
lookup (cons O (cons I nil)) (fs fz)




run {Fin {suc (suc zero)}}{Fin {suc (suc zero)}} (somefin (\n. Cont (Fin {n}) (Fin {n})) (\{n} f. cont (\k. k (run {Fin {suc n}}{Fin {n}} (cont (\k. k (run f (\x. x)))) fs))) (\{n}. cont (\k. k fz))) (\x. x)

run {Vec {suc (suc zero)} Bit}{Vec {suc (suc zero)} Bit}
    (somevec
        (\n. Cont (Vec {n} Bit) (Vec {n} Bit))
        (cont (\k. k nil))
        (\{n} a as. cont (\k. k (run
            {Vec {suc n} Bit}{Vec {n} Bit}
            (cont (\k. k (run as (\x. x))))
            (cons a)))))
    (\x. x)

(the
    ({n : Nat} -> Bit -> Cont (Vec {suc n} Bit) (Vec {n} Bit) -> Cont (Vec {suc n} Bit) (Vec {suc n} Bit))
    (\{n} a as. cont
        {Vec {suc n} Bit}{Vec {suc n} Bit}
        (\k. k (run
            {Vec {suc n} Bit}{Vec {n} Bit} as (cons a)))))
{zero} I (cont (\k. k nil))



run {Vec {suc (suc zero)} Bit}{Vec {zero} Bit -> Vec {suc (suc zero)} Bit}
    (somevec
        (\n. Cont (Vec {zero} Bit -> Vec {n} Bit) (Vec {zero} Bit -> Vec {n} Bit))
        (cont (\k. k (\x. x)))
        (\{n} a as. cont (\k. k (run
            {Vec {zero} Bit -> Vec {suc n} Bit}{Vec {zero} Bit -> Vec {n} Bit}
            (cont (\k. k (run as (cons a))))
            (\x. x)))))
    (\k. k nil)


run
    {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
    {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
    (cont
        {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
        {{n} -> Vec {n} Bit -> Vec {n} Bit}
        (\k {n} (v : Vec {n} Bit). k (\w. w) v))
    (cons a)


run
            {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
            {{n} -> Vec {n} Bit -> Vec {n} Bit}
            (cont
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                (\q. run (cont (\k. k (\x. x))) (q (\x. x))))
            ((\x. x) (cons I))
nil

run (somevec
    _
    (cont (\k. k (\x. x)))
    (\{n} a as. cont
        (\k. run (cont
            (\q. run as (q (cons a)))) (k (\x. x)))))
(\f. f nil)
                
cont
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                (\q. run (cont (\k. k (\x. x))) (q (\x. x)))

let fold : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A) (\p. pair (suc (fst p)) (p reducer)) (pair zero base));


nil => base, O : nil => f O base, I : O : nil => f I (f O base)
nil => base, O : nil => f base O, I : O : nil => f (f base O) I

let foldvec : {A n} -> ({m} -> Vec {suc m} A -> A -> A) -> A -> Vec {n} A -> A
    = \{A}{n} reducer base v. snd {Vec {n} A} (v
        (\n. Pair (Vec {n} A) A)
        (pair nil base)
        (\a p. pair (cons a (fst p)) (p A (\v. reducer (cons a v)))));
foldvec {Bit} (\v acc. or acc (head v)) O (cons I (cons O nil))

foldtree {Bit} (\b. b) (\lt acc. acc) (\lt acc. acc) sometree

let dfoldvec : {A}{B : Nat -> U}{n} -> ({m} -> Vec {suc m} A -> B m -> B (suc m)) -> B zero -> Vec {n} A -> B n
    = \{A}{B}{n} reducer base v. snd {Vec {n} A} (v
        (\n. Pair (Vec {n} A) (B n))
        (pair nil base)
        (\{m} a p. pair (cons a (fst p)) (p (B (suc m)) (\v. reducer {m} (cons a v)))));
dfoldvec {Bit}{\n. LTree {n} Bit -> Bit}
    (\{m} v acc lt. acc ((head v) (LTree {suc m} Bit -> LTree {m} Bit) (lbranch {Bit}) (rbranch {Bit}) lt))
    divine somevec sometree

let dfoldfin : {A : Nat -> U}{n} -> ({m} -> Fin {suc m} -> A m -> A (suc m)) -> ({m} -> A (suc m)) -> Fin {suc n} -> A (suc n)
    = \{A}{n} reducer base fn. snd {Fin {suc n}} (fn
        (\n. Pair (Fin {n}) (A n))
        (\{m} p. pair (fs (fst p)) (p (A (suc m)) (\f. reducer {m} (fs f))))
        (\{m}. pair fz (base {m})));
dfoldfin {\_. Bit} (\fn acc. not acc) O (fs (fs fz))


(O (LTree Bit -> LTree Bit) (lbranch {Bit}{zero}) (rbranch {Bit}{zero})) (node (leaf I) (leaf O))
divine (lbranch {Bit}{zero} (node (leaf I) (leaf O)))



dfoldfin {Bit}
    (\{m} fn acc v. acc (fn (\n. Vec {n} Bit) tail v))
    head fz (cons O nil)



let lookup : {A}{n} ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A -> A) ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A) ->
    Pair (Vec {suc n} A) (Fin {suc n}) -> A
    = \{A}{n} reducer base p. snd {Pair (Vec {suc n} A) (Fin {suc n})} (p A (\v fn. pair
        (v _ _ _)
        (fn _ _ _)));

let lookup : {A n} ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A -> A) ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A) ->
    Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} reducer base v fn. snd {Pair (Vec {suc n} A) (Fin {suc n})} (pair
        (reducer)
        (base));

let lookup : {A n} -> Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} v fn. fn (\_. A) _ (head v);
lookup {Bit} (cons O nil) fz

let foldlookup : {A n} ->
    ({m} -> Pair (Fin {suc m}) (Vec {suc m} A) -> Pair (Fin {m}) (Vec {m} A) -> Pair (Fin {suc m}) (Vec {suc m} A)) ->
    ({m} -> Pair (Fin {suc m}) (Vec {suc m} A)) -> Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} reducer base v fn. head (snd {Fin {suc n}} (fn
        (\n. Pair (Fin {n}) (Vec {n} A))
        (\{m} f p. p (Pair (Fin {suc m}) (Vec {suc m} A)) (\fn v. reducer {m} (pair (fs fn) (cons a v)) (pair fn v)))
        (\{m}. pair fz (base {m}))));
foldlookup {Bit}{\n. Pair (Fin {n}) (Vec {n} A)}
    (\v acc. or acc (head v)) O (cons I (cons O nil))


foldvec {Bit}{\n. Fin {suc n}} (\v acc. if (head v) acc (fs acc)) fz (cons I (cons O nil))


let Reflects : U -> Bit -> U                          = \P b. (R : Bit -> U) -> (P -> R I) -> (neg P -> R O) -> R b;
let ofyes : {P} -> P -> Reflects P I                  = \p R y n. y p;
let ofno : {P} -> neg P -> Reflects P O               = \negp R y n. n negp;

let of : {P}{b : Bit} -> b U P (neg P) -> Reflects P b
    = \{P}{b} p. b (Reflects P b) (the (Reflects P I) (ofyes p)) (ofno p);


let of : {P}{b : Bit} -> Either (P -> Reflects P I) ((neg P) -> Reflects P O)
    = \{P}{b}. b (_) (left ofyes) (right ofno);

let of : {P}{b : Bit} -> Either P (neg P) -> Reflects P b
    = \{P}{b} e. e (Reflects P b) (ofyes) (ofno);


someDNatPair (Fin {suc (suc zero)}) (\a b.
    (\n. b (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n}))
    (a _ suc zero))

the (Fin {suc zero}) ((\n. dz (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n})) zero)
(\n. dz (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n})) zero

the (Fin {suc zero}) ((\n. dz (\m. Fin {suc (add m n)}) fs fz) zero)



-- Identity index

let Wrap : {T} -> T -> U                              = \{T} t. (W : {T} -> T -> U) -> ({V} -> (v : V) -> W {V} v) -> W {T} t;
let wrap : {T} -> (t : T) -> Wrap {T} t               = \{V} v W w. w {V} v;
let unwrap : {T t} -> Wrap {T} t -> T                 = \{V}{v} w. w (\_. V) (\_. v);

tt (Wrap tt) ((\t. tt (Wrap {Unit} t) (wrap t)) tt)


let Eq : {T} -> T -> T -> U
    = \{T} x y. (P : T -> T -> U) -> ((t : T) -> (u : T) -> P t u) -> P x y;
let refl : {T}{t : T} -> Eq {T} t t                   = \{T}{t} P r. r t t;
let unrefl : {T x y} -> Eq {T} x y -> Pair T T        = \{T}{x}{y} r. r (\_ _. Pair T T) (\_ _. pair x y);

let cong : (f : {B} -> (A : U) -> B){x y} -> Eq x y -> Eq (f x) (f y)
    = \f {x}{y} r P cr. cr (f x) (f y);
let sym : {x y} -> Eq x y -> Eq y x
    = \{x}{y} r P sr. sr y x;
let trans : {x y z} -> Eq x y -> Eq y z -> Eq x z
    = \{x}{y}{z} rxy ryz P tr. tr x z;

let sucAssoc : {m n} -> Eq (add (suc m) n) (suc (add m n)) = refl;

--tt ({m n} -> Eq (add m n) (add n m)) ({m} -> m (Eq _ _) 
--  (\n. trans refl refl)
--  (trans refl refl))
tt (Eq {Bit} I O) (\P r. r I O)



let Eq : {T} -> T -> T -> U = \{T} x y. (P : T -> U) -> P x -> P y;
let refl : {T t} -> Eq {T} t t = \P pt. pt;

--\(n : Nat). n ({a b} -> Eq (add a (suc b)) (suc (add a b)))
--  (\acc. _) (tt (Eq (add zero (suc b)) (suc (add zero b))) refl)

--\(b : Nat). tt (Eq (add zero (suc b)) (suc (add zero b))) refl
--\b (acc : {a} -> Eq (add (suc a) (suc b)) (suc (add (suc a) b))). tt (_) (refl (\n. EP (suc n)) acc)
tt ({a : Nat}(b : Nat) -> Eq (add (suc a) (suc b)) (suc (add (suc a) b))) (\(b : Nat) P px. refl _ px)

--\N s z. s (m N s (n N s z))
--\N s z. m N s (s (n N s z))

--\N s z. s (n N s z)


--\N s z. s (_)
--\N s z. s (_)

--\n. (add zero (suc n))
--\n. suc (add zero n)

--\m n. add m (suc n)
--\m n. suc (add m n)

-- Equality
{-
let Vec : {n} -> U -> U                             = \{n} A. (V : Nat -> U) -> V zero -> ({m} -> A -> V m -> V (suc m)) -> V n;
let Eq : {T} -> T -> T -> U = \{T} x y. (E : T -> U) -> ({t} -> E t -> E t) -> E x -> E y;
let refl : {T t} -> Eq {T} t t = \E e et. e et;

let cong : {A B}(f : A -> B){x y} -> Eq x y -> Eq (f x) (f y)
    = \{A}{B} f {x}{y} r E e exy. r _ e (e exy);


-tt (Eq {Bit} I I) (cong {Bit}{Bit} not {O}{O} (refl {Bit}{O}))
-}



let EquivNats : IsEquivalence {Nat} Eq
    = \E. E (refl {Nat}) (\{x}{y} pxy. _) (\{i}{j}{k} reljk relij. _);
--tt (Symmetric (Eq {Nat})) (\{x}{y} pxy. x _ (\acc. acc) pxy)


let PairSum : {k} -> U
    = \{k}. (PS : Nat -> U) -> ({m n} -> DNat {m} -> DNat {n} -> PS (add m n)) -> PS k;
let pairzero : PairSum {zero}
    = \PS p. p dz dz;
let lsuc : {n} -> PairSum {n} -> PairSum {suc n}
    = \ps PS p. ps PS (\{m}{n} l r. p {suc m}{n} (ds {m} l) r);
let rsuc : {n} -> PairSum {n} -> PairSum {suc n}
    = \ps PS p. ps PS (\{m}{n} l r. p {m}{suc n} l (ds {n} r));

(\{A}{n}(fn : Fin {n})(v : Vec {n} A). (\k. v (\_. A) _ (\{n} a acc. (add (minus k n) (minus n k)) A (\_. acc) a))
    (fn (\_. Nat) suc zero)) {Bit} (fs fz) (cons I (cons O nil))



let cmpBitVec : {n} -> Vec {n} Bit -> Vec {n} Bit -> Bit
    = \{n} v1 v2. v1 (\_. Bit) I (\{m} a acc. and acc (xnor a (lookup {m=n} m v2)));
--let cmpWord : {n} -> LTree {n} Bit -> LTree {n} Bit -> Bit
--    = \{n} tr1 tr2. proj2 {Nat}{\n. Vec {n} Bit} (tr1);


tt (Eq (node (leaf I) (leaf I)) (node (leaf I) (leaf I))) refl


{-let getBit : {n} -> Vec {n} Bit -> LTree {n} Bit -> Bit = lookupTree {Bit};
let setBit : {n} -> Vec {n} Bit -> LTree {n} Bit -> Bit -> LTree {n} Bit
    = \{n} v tr b. tr (\n. LTree {n} Bit) (\b. leaf b) (\{m} l r. node l r);
setBit (cons I nil) (initWord (ds dz))-}


let foldnat : {A : Nat -> U}{n} -> ({m} -> A m -> A (suc m)) -> A zero -> Nat -> A n
    = \{A} reducer base n. proj2 {Nat} (n (Sigma Nat A)
        (\s. dpair {Nat}{A} (suc (proj1 s)) (reducer (proj2 s))) (dpair zero base));
let fact : Nat -> Nat = \n. foldnat {\_. Nat} (\{m}. mul m) (suc zero) n;
fact (suc (suc (suc zero)))

-- first projection is in type, so cannot change during induction over a non-dependent type
(suc (suc zero)) (Sigma Nat (\_. Nat))
    (\acc. acc (\_. Sigma Nat (\_. Nat)) (\fst snd. dpair fst (suc snd)))
    (dpair zero zero)

-- Access a dependent nat from a computable plain nat
(ds (ds dz)) (\n. DNat {n Nat (\acc N s z. s (s (acc N s z))) zero}) (\acc DN s z. s (s (acc DN s z))) dz





-- W types

let W : {WSh}(C : Container {WSh}) -> U
    = \{WSh} C. {w : {Sh} -> Container {Sh} -> U} ->
        ({sh}{c : Container {sh}} -> (sup : cextend {sh} c (w {sh} c) -> w {sh} c) -> w {sh} c) -> w {WSh} C;
let sup : {Sh}{C : Container {Sh}} -> (cextend {Sh} C (W {Sh} C) -> W {Sh} C) -> W {Sh} C
    = \{Sh}{C} s {W} w. w {Sh}{C} s;
let whead : {WSh}{C : Container {WSh}} -> W {WSh} C -> cshape C
    = \{WSh}{C} w. w (\{sh}{c} sup. _);

whead



let WC : {Sh} -> Container {Sh} -> U
    = \{Sh} C. (W : U) -> (sup : (cextend C) W -> W) -> W;
--let supC : {Sh}{C : Container {Sh}} -> (cextend C) (WC C) -> WC C
--    = \{Sh}{C} cxw W s. cxw (\_. WC C) (\sh pos. s sh pos);
--supC
--WC (cpair Nat (\n. Fin {n}))

let WT : (A : U)(B : A -> U) -> U
    = \A B. (W : (X : U)(Y : X -> U) -> U) -> ((sup : {X}{Y : X -> U}(x : X)(yx : Y x -> W X Y) -> W X Y) -> W A B) -> W A B;
let supT : {A}{B : A -> U}(a : A)(b : B a -> WT A B) -> WT A B = \{A}{B} a b _ W. W (\sup. _);
--supT
--WT Nat (\n. Fin {n})


\{Sh}{X}{Y}(C : Container {Sh})(Rel : X -> Y -> U)(cx : cextend {Sh} C X)(cy : cextend {Sh} C Y)(shape : Eq {Sh} (proj1 {Sh} cx) (proj1 {Sh} cy)){px}.
    (proj2 {Sh} cy (subst {Sh} (cposition {Sh} C) shape px))

{-
let Pointwise : {Sh X Y}(C : Container {Sh})(Rel : X -> Y -> U)
                (cx : cextend {Sh} C X)(cy : cextend {Sh} C Y) -> U
    = \{Sh} C Rel cx cy. {P} -> ((shape : Eq {Sh} (proj1 {Sh} cx) (proj1 {Sh} cy)) ->
        (position : {px} -> Rel (proj2 {Sh} cx px) (proj2 {Sh} cy (subst {Sh} (cposition {Sh} C) shape px))) -> P) -> P;

Pointwise
-}



let IndexedReflexive : {I i1 i2}{A : I -> U} -> (A i1 -> A i2 -> U) -> U =
    \Rel. {x} -> Rel x x;
let IndexedSymmetric : {I i1 i2}{A : I -> U} -> (A i1 -> A i2 -> U) -> U = Symmetric;
let IndexedTransitive : {I i1 i2}{A : I -> U} -> (A i1 -> A i2 -> U) -> U = Transitive;
let IsIndexedEquivalence : {I i1 i2}{A : I -> U} -> (A i1 -> A i2 -> U) -> U
    = \{A=A} Rel. {E} -> ((refl : IndexedReflexive {A=A} Rel)
        (sym : IndexedSymmetric {A=A} Rel)(trans : IndexedTransitive {A=A} Rel) -> E) -> E;
let IndexedSetoid : {A}{Rel : A -> A -> U} -> U -> U
    = \{Rel=Rel} I. {IS : {T : I -> U} -> (T -> T -> U) -> U} -> ({T}(rel : T -> T -> U)
        (isEquiv : IsIndexedEquivalence {T} rel) -> IS rel) -> IS Rel;
let EqPreservingFunction : (From : Setoid) -> IndexedSetoid (carrier From) -> U
    = \From To. _;
EqPreservingFunction




-- Traversables

let Trav : (F : U -> U) -> U
    = \F. (S : U -> U){T} -> ((traverse : {G : U -> U}{app : App G}{B A} -> (A -> G B) -> F A -> G (F B)) -> S (F T)) -> S (F T);
--let ltreeTrav : {n} -> Trav (LTree {n})
--    = \_ T. T (\{F}{app}{B} f ta. app (\pure ap. ta (\n. F (LTree {n} B))
--        (\a. ap (pure leaf) (f a)) (\{m} l r. ap (ap (pure node) l) r)));

let vecTrav : {n} -> Trav (Vec {n})
    = \{n} _ T. T (\{F}{app}{B} f va. app {Vec {n} B} (\pure ap. va (\n. F (Vec {n} B))
        (pure nil) (\{m} a as. ap (ap (pure cons) (f a)) as)));
let maybeNonzero : Nat -> Maybe Nat = \n. n (Maybe Nat) (\s. just n) nothing;
--vecTrav Maybe (\traverse. traverse {app=maybeApp} maybeNonzero (cons (suc zero) nil))


let Zipper : (F : U -> U)(A : U) -> U
    = \F A. (Z : (U -> U) -> U -> U) -> ({G : U -> U}{B} -> G B -> Z G B) ->
      ({G : U -> U}{B} -> B -> (Maybe B -> Z G B) -> Z G B) -> Z F A;
let makeZipper : {F : U -> U}{trav : Trav F}{A} -> F A -> Zipper F A
    = \{F}{trav}{A} fa Z zdone zstep. trav (Cont A) (\traverse. run
        (traverse {app=contApp} (\a. cont (\k. zstep a (dcomp k (maybe a id)))) fa) zdone);

makeZipper




(vcons {Bit} O vnil) (\n. Sigma (Pair Nat Nat) (\p. Pair (Vec {fst p} Bit) (Vec {snd p} Bit)) {pair n (pred n)})
    (dpair {Pair Nat Nat}{\p. Pair (Vec {fst p} Bit) (Vec {snd p} Bit)} (pair zero zero) (pair vnil vnil))
    (\{m} a s. dpair {Pair Nat Nat}{\p. Pair (Vec {fst p} Bit) (Vec {snd p} Bit)} (pair (suc (fst (proj1 s))) (fst (proj1 s))) (pair (vcons {Bit} a (fst (proj2 s))) (fst (proj2 s))))




-- F-Algebras **Requires Fixpoint

let Algebra : (F : U -> U){functor : Functor F}(A : U) -> U
    = \F A. {T} -> ((alg : F A -> A) -> F T) -> F T;
let Arith : U -> U =
    \T. (const : Nat -> T)(add : T -> T -> T)(mul : T -> T -> T) -> T;
let arithConst : {T} -> Nat -> Arith T = \n c a m. c n;
let arithAdd : {T} -> Arith T -> Arith T -> Arith T = \x y c a m. a (x c a m) (y c a m);
let arithMul : {T} -> Arith T -> Arith T -> Arith T = \x y c a m. m (x c a m) (y c a m);

let expr : {T} -> Arith T = arithAdd (arithConst (suc zero)) (arithConst (suc zero));
expr {Nat} id add mul

-- Needs fn : A -> B, not fn : Nat -> A
let arithFunctor : Functor Arith = \F. F (\fn ar c a m. ar fn a m);
let arithAlg : Algebra Arith = _;




-- Leibniz Equality as record

let Eq : {T} -> T -> T -> U                           = \{T} x y. (P : T -> U) -> ((refl : {Z z}{Q : Z -> U} -> Q z -> Q z) -> P x -> P y) -> P x -> P y;
let refl : {T t} -> Eq {T} t t                        = \_ E. E (\refl. refl);
let trans : {T}{x y z : T} -> Eq y z -> Eq x y -> Eq {T} x z
    = \yz xy P E. E (\refl. refl);
let sym : {T}{x y : T} -> Eq x y -> Eq {T} y x        = \{T}{x} xy P. xy (\z. P z -> P x) (refl {T} P);
let cong : {A B x y}(f : A -> B) -> Eq x y -> Eq {B} (f x) (f y) = \f xy P. xy (\x. P (f x));


\(a : Nat)(b : Nat)(c : Nat)(bc : Eq {Nat} b c)(ab : Eq {Nat} a b). tt (Eq {Nat} a c)
    (trans {Nat}{a}{b}{c} bc ab)




-- Trees

let Tree : U -> U = \A. (T : U) -> (T -> T -> T) -> (A -> T) -> T -> T;
let tnil : {A} -> Tree A = \T n l t. t;
let leaf : {A} -> A -> Tree A = \a T n l t. l a;
--let node : {A} -> Tree A -> Tree A -> Tree A
--    = \ta tb T n l t. ta T n (\a. tb T n (\b. n (l a) (l b)) (l a)) (tb T n l t);
let node : {A} -> Tree A -> Tree A -> Tree A = \ta tb T n l t. n (ta T n l t) (tb T n l t);
let norm : {A} -> Tree A -> Tree A
    = \{A} tr. tr (Tree A) (\ta tb. ta (Tree A)
        (\al ar. tb (Tree A) (\bl br. node (node al ar) (node bl br))
            (\b. node (node al ar) (leaf b)) (node al ar))
        (\a. tb (Tree A) (\bl br. node (leaf a) (node bl br))
            (\b. node (leaf a) (leaf b)) (leaf a)) tb) leaf tnil;

norm (node (node (leaf zero) (leaf (suc zero))) (node (leaf (suc (suc zero))) tnil))

let TreeIsMagma : {T} -> IsMagma {Tree T} Eq node     = \IsM. IsM EqIsEquiv (cong2 node);
let TreeMagma : {T} -> Magma {Tree T} = \{T} M. M {Tree T}{Eq {Tree T}}{node} TreeIsMagma;
--TreeMagma (\IsM. IsM (\IsEquiv opcong. IsEquiv (\refl sym trans. refl)))

let TreeIsUnitalMagma : {T} -> IsUnitalMagma {Tree T} Eq node tnil = \IsUM. IsUM TreeIsMagma (pair refl refl);
let TreeUnitalMagma : {T} -> UnitalMagma {Tree T} = \{T} UM. UM {Tree T}{Eq {Tree T}}{node}{tnil} TreeIsUnitalMagma;
--TreeUnitalMagma {Bit} (\IsUM. IsUM (\IsM Iden. IsM (\IsEquiv opcong. IsEquiv (\refl sym trans. refl))))


let foldvec
    : {A}{S : U -> U}{Z : U}{n} -> ({B m} -> Vec {m} A -> A -> B -> S B) -> Z -> Vec {n} A -> n U S Z
    = \{A}{B} reducer base v. snd (proj2 {Nat}{\n. Pair (Vec {n} A) (n U S Z)} (v
        (\n. Sigma Nat (\n. Pair (Vec {n} A) (n U S Z)) {n})
        (dpair zero (pair vnil base))
        (\{m} a s. dpair (suc m)
          (pair (vcons a (fst (proj2 s))) (reducer (fst (proj2 s)) a (snd (proj2 s)))))));

let foldnat : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A)
        (\p. pair (suc (fst p)) (reducer (fst p) (snd p))) (pair zero base));
let pred : Nat -> Nat = foldnat const zero;
foldvec {Bit}{\n. Vec {pred n} Bit} (\{m} v _ _. v) vnil (vcons I (vcons O vnil))



let dfoldnat
    : {S : Nat -> U -> U}{Z : U}{n} -> ({A m} -> DNat {m} -> A -> S m A) -> Z -> DNat {n} -> foldnat {U} S Z n
    = \{S}{Z}{n} reducer base dn. snd (proj2
        {Pair Nat U}{\p. Pair (DNat {fst p}) (snd p)}{pair n (foldnat {U} S Z n)} (dn
          (\n. Sigma (Pair Nat U) (\p. Pair (DNat {fst p}) (snd p)) {pair n (foldnat {U} S Z n)})
          (\{m} s. dpair {Pair Nat U} {\p. Pair (DNat {fst p}) (snd p)}
            (pair {Nat}{U} (suc m) (foldnat {U} S Z (suc m)))
            (pair {DNat {suc m}}{foldnat {U} S Z (suc m)}
              (ds (fst (proj2 s)))
              (reducer {foldnat {U} S Z m}
                {fst (m (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p))) (pair zero Z))}
                (fst {DNat {fst (m (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p))) (pair zero Z))}}
                  (proj2 {Pair Nat U}{\p. Pair (DNat {fst p}) (snd p)}{pair (fst (m (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p)))) (pair zero Z)) (foldnat {U} S Z m)} s))
                  (snd (proj2 s)))))
          (dpair (pair zero Z) (pair dz base))));

--dfoldnat {\_ _. Vec {zero} Bit}{Vec {zero} Bit}{Nat}{suc (suc zero)} (\dn a. vnil) vnil (ds (ds dz))
--snd (n (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p))) (pair zero Z))
foldnat {U} (\n _. DNat {n}) (DNat {zero}) (suc (suc zero))



let dfoldnat
    : {S : Nat -> U -> U}{Z : U}{n} -> ({A m} -> DNat {m} -> A -> S m A) -> Z -> DNat {n} -> foldnat {U} S Z n
    = \{S}{Z}{n} reducer base dn. snd (proj2
        {Pair Nat U}{\p. Pair (DNat {fst p}) (snd p)}{pair n (foldnat {U} S Z n)} (dn
          (\n. Sigma (Pair Nat U) (\p. Pair (DNat {fst p}) (snd p)) {pair n (foldnat {U} S Z n)})
          (\{m} s. dpair {Pair Nat U} {\p. Pair (DNat {fst p}) (snd p)}
            (pair {Nat}{U} (suc m) (foldnat {U} S Z (suc m)))
            (pair {DNat {suc m}}{foldnat {U} S Z (suc m)}
              (ds (fst (proj2 s)))
              (reducer {foldnat {U} S Z m}{m} (fst (proj2 s)) (snd (proj2 s)))))
          (dpair (pair zero Z) (pair dz base))));


let dfoldnat
    : {A : Nat -> U}{S : Nat -> U -> U}{Z : U}{n} ->
        ({m} -> DNat {m} -> A m -> S m (A m)) -> Z -> DNat {n} -> foldnat {U} S Z n
    = \{A}{S}{Z}{n} reducer base dn. snd (proj2 {Nat}{\n. Pair (DNat {n}) (foldnat {U} S Z n)}{n} (dn
          (\n. Sigma Nat (\n. Pair (DNat {n}) (foldnat {U} S Z n)) {n})
          (\{m} s. dpair {Nat}{\n. Pair (DNat {n}) (foldnat {U} S Z n)} (suc m)
            (pair {DNat {suc m}}{S m (A m)}
              (ds {m} (fst (proj2 s)))
              (reducer {m} (fst (proj2 s)) (snd (proj2 s)))))
          (dpair (zero) (pair dz base))));
dfoldnat



(\(S : Nat -> U -> U)(Z : U)(n : Nat)(A : Nat -> U)
  (reducer : {m} -> DNat {m} -> A m -> S m (A m))(base : Z)(dn : DNat {n})
  (s : Sigma Nat (\n. Pair (DNat {n}) (A n)) {n}).
    reducer (fst (proj2 s)) (snd (proj2 s)))
  (\n _. Fin {suc (suc n)}) (Fin {suc zero}) zero (\n. Fin {suc n})
  (\{m} _ (fn : Fin {suc m}). fs {suc m} fn) fz (dz)
  (dpair {Nat}{\n. Pair (DNat {n}) (Fin {suc n})}
    (zero) (pair dz fz))

(\(S : Nat -> U -> U)(Z : U)(n : Nat)(A : Nat -> U)(base : Z)(dn : DNat {n}).
  subst (const U) (tt (Eq {U}
    (snd (n (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p))) (pair zero Z)))
    (foldnat S Z n)) refl) (snd (n (Pair Nat U) (\p. pair (suc (fst p)) (S (fst p) (snd p))) (pair zero Z))))
  (\n _. Fin {suc (suc n)}) (Fin {suc zero}) (suc zero) (\n. Fin {suc n})
  fz (ds dz)




let test
    : (A : Nat -> U)(S : Nat -> U -> U)(Z : U)(n : Nat)
        (reducer : {m} -> DNat {m} -> A m -> S m (A m))(base : Z)(dn : DNat {n}) ->
        Sigma Nat (\n. Pair (DNat {n}) (foldnat {U} S Z n)) {n}
    = \A S Z n reducer base dn s. dn
        (\n. Sigma Nat (\n. Pair (DNat {n}) (foldnat {U} S Z n)) {n})
        (\{m} s. dpair {Nat}{\n. Pair (DNat {n}) (foldnat {U} S Z n)} (suc m)
          (pair {DNat {suc m}}{foldnat {U} S Z (suc m)}
            (ds (fst {DNat {m}} (proj2 {Nat} s)))
            (reducer {m}
              (fst {DNat {m}} (proj2 {Nat} s))
              (snd {DNat {m}} (proj2 {Nat} s)))))
        (dpair {Nat} zero (pair dz base));
test
  (\n. Fin {suc n}) (\n _. Fin {suc (suc n)}) (Fin {suc zero}) zero
  (\{m} _ (fn : Fin {suc m}). fs {suc m} fn) fz (dz)
  (dpair {Nat}{\n. Pair (DNat {n}) (Fin {suc n})}
    (zero) (pair dz fz))

(\(S : Nat -> U -> U)(n : Nat)(A : Nat -> U)
  (reducer : {m} -> DNat {m} -> S m (A m) -> S (suc m) (A (suc m)))(base : S zero (A zero))(dn : DNat {n}). snd (proj2 {Nat}{\n. Pair (DNat {n}) (S n (A n))}{n} (dn
    (\n. Sigma Nat (\n. Pair (DNat {n}) (S n (A n))) {n})
    (\{m} s. dpair {Nat}{\n. Pair (DNat {n}) (S n (A n))} (suc m)
      (pair {DNat {suc m}}{S (suc m) (A (suc m))} (ds (fst (proj2 s)))
        (reducer (fst (proj2 s)) (snd (proj2 s)))))
    (dpair zero (pair dz base)))))
  (\n _. Fin {suc n}) zero (\n. Fin {suc n})
  (\{m} _ (fn : Fin {suc m}). fs {suc m} fn) fz (dz)



let dfoldnat
    : {n}(S : Nat -> U -> U)(A : Nat -> U) ->
      ({m} -> DNat {m} -> S m (A m) -> S (suc m) (A (suc m))) -> S zero (A zero) -> DNat {n} -> S n (A n)
    = \{n} S A reducer base dn. snd (proj2 {Nat}{\n. Pair (DNat {n}) (S n (A n))}{n} (dn
    (\n. Sigma Nat (\n. Pair (DNat {n}) (S n (A n))) {n})
    (\{m} s. dpair {Nat}{\n. Pair (DNat {n}) (S n (A n))} (suc m)
      (pair {DNat {suc m}}{S (suc m) (A (suc m))} (ds (fst (proj2 s)))
        (reducer (fst (proj2 s)) (snd (proj2 s)))))
    (dpair zero (pair dz base))));
dfoldnat (\m _. DNat {m}) (\m. DNat {m})
  (\{m} dn _. dn) dz (ds (ds dz))



(\{n : Nat}(S : Nat -> U -> U)(A : Nat -> U){m : Nat}(f : Nat -> Nat -> Nat)
  (reducer : {p q} -> DNat {p} -> S q (A p) -> S (f q p) (A (suc p)))(base : S m (A zero))(dn : DNat {n}).
  snd (proj2 {Nat}{\n. Pair (DNat {n}) (S (foldnat f m n) (A n))}{n} (dn
    (\n. Sigma Nat (\n. Pair (DNat {n}) (S (foldnat f m n) (A n))) {n})
    (\{k} s. dpair {Nat}{\n. Pair (DNat {n}) (S (foldnat f m n) (A n))} (suc k)
      (pair {DNat {suc k}}{S (foldnat f m (suc k)) (A (suc k))} (ds (fst (proj2 s)))
        (reducer {k}{foldnat f m k} (fst (proj2 s)) (snd (proj2 s)))))
    (dpair zero (pair dz base)))))
  (\m _. DNat {m}) (\m. DNat {m}) const
  (\{m} dn _. dn) dz (ds (ds dz))

let dfoldnat
    : {S : U -> U}{Z : U}{n} -> ({A m} -> DNat {m} -> A -> S A) -> Z -> DNat {n} -> n U S Z
    = \{S}{Z}{n} reducer base dn. snd (proj2 {Nat}{\n. Pair (DNat {n}) (n U S Z)} (dn
        (\n. Sigma Nat (\n. Pair (DNat {n}) (n U S Z)) {n})
        (\{m} s. s (\n. Sigma Nat (\n. Pair (DNat {n}) (n U S Z)) {suc n}) (\_ dsnd. dpair 
          (suc m)
          (pair (ds (fst dsnd)) (reducer (fst dsnd) (snd dsnd)))))
        (dpair zero (pair dz base))));
dfoldnat {\_. Vec {zero} Bit}{Vec {zero} Bit}{suc (suc zero)} (\dn a. vnil) vnil (ds (ds dz))



let Leq : Nat -> Nat -> U
    = \m n. (LE : Nat -> Nat -> U) -> ({a b} -> LE a b -> LE (suc a) (suc b)) -> ({n} -> LE zero n) -> LE m n;
let ls : {m n} -> Leq m n -> Leq (suc m) (suc n) = \leq LE s z. s (leq LE s z);
let lz : {n} -> Leq zero n = \LE s z. z;

let leqTrans : {m n o} -> Leq m n -> Leq n o -> Leq m o
    = \{m}{n}{o} mn no. no Leq ls
        (\{osubn}. mn Leq ls
          (\{nsubm}. lz {add nsubm osubn}));

let leqTransZero : {n o} -> Leq n o -> Leq zero n -> Leq zero o
    = \{n}{o} no zn. lz {o};
let leqTransSuc : {m n o}{ni : NatInd {n}} -> Leq n o ->
        (Leq m n -> Leq m o) -> Leq (suc m) n -> Leq (suc m) o
    = \{n}{o}{ni} no base sn. base sn;
leqTransSuc

let antisymZero : {m} -> Leq m zero -> Leq zero m -> Eq {Nat} m zero = \mz zm P pz. _;
antisymZero
let antisym : {m n} -> Leq m n -> Leq n m -> Eq m n
    = \{m}{n} mn nm P px.



(\{n : Nat}(S : Nat -> U -> U)(A : Nat -> U){m : Nat}(f : Nat -> Nat -> Nat)
  (reducer : {p q} -> DNat {p} -> S q (A p) -> S (f q p) (A (suc p)))(base : S m (A zero))(dn : DNat {n})
  {k : Nat}(s : Sigma Nat (\p. Pair (DNat {p}) (S (foldnat f m p) (A p))) {k}). s
    (\l. Sigma Nat (\p. Pair (DNat {p})(S (foldnat f m p) (A p))) {suc l})
    (\dfst dsnd. dpair {Nat}{\p. Pair (DNat {p})(S (foldnat f m p) (A p))} (suc dfst)
      (pair {DNat {suc dfst}}{S (foldnat f m (suc dfst)) (A (suc dfst))}
        (ds (fst dsnd)) (reducer {dfst}{foldnat f m dfst} (fst dsnd) (snd dsnd)))))
  {zero} (\_ T. T) (\m. DNat {m}) const
  (\{a}{b} dn _. ds dn) dz dz
  (dpair zero (pair dz dz))



(\{n : Nat}(S : Nat -> U -> U)(A : Nat -> U){m : Nat}(f : Nat -> Nat -> Nat)
  (reducer : {p q} -> DNat {p} -> S q (A p) -> S (f p q) (A (suc p)))(base : S m (A zero))(dn : DNat {n})
  {k : Nat}(s : Sigma Nat (\p. Pair (DNat {p}) (S (foldnat f m p) (A p))) {k}). s
    (\l. Pair (DNat {suc l}) (S (f l (foldnat {Nat} f m l)) (A (suc l))))
    (\dfst dsnd. pair (ds (fst dsnd))
      (reducer {dfst}{foldnat f m dfst} (fst dsnd) (snd dsnd))))
  {zero} (\m _. DNat {m}) (\m. DNat {m}) {zero} const
  (\{a}{b} dn _. dn) dz dz
  (dpair zero (pair dz dz))


tt (Pair (DNat {suc zero}) (DNat {zero})) ((\{n : Nat}(S : Nat -> U -> U)(A : Nat -> U){m : Nat}(f : Nat -> Nat -> Nat)
  (reducer : {p q} -> DNat {p} -> S q (A p) -> S (f p q) (A (suc p)))(base : S m (A zero))(dn : DNat {n})
  {k : Nat}(s : Sigma Nat (\p. Pair (DNat {p}) (S (foldnat f m p) (A p))) {k}). s
    (\l. Pair (DNat {suc l}) (S (f l (foldnat f m l)) (A (suc l))))
    (\dfst dsnd. pair (ds (fst dsnd))
      (reducer (fst dsnd) (snd dsnd))))
  {zero} (\m _. DNat {m}) (\m. DNat {m}) {zero} const
  (\{a}{b} dn _. dn) dz dz
  (dpair zero (pair dz dz)))

(\{n : Nat}(G : Nat -> U -> U)(H : Nat -> U){m : Nat}(f : Nat -> Nat -> Nat)
  (reducer : {p q} -> DNat {p} -> G q (H p) -> G (f p q) (H (suc p)))(base : G m (A zero))(dn : DNat {n}).
  snd (proj2 (dn
    (\n. Sigma Nat (\n. Pair (DNat {n}) (G (foldnat f m n) (H n))) {n})
    (\{k} s. s
--      (\o. Sigma Nat (\l. Pair (DNat {suc l}) (G (foldnat f m (suc l)) (H (suc l)))) {o})
      (\o. Sigma Nat (\l. Pair (DNat {l}) (G (foldnat f m l) (H l))) {o})
      (\dfst dsnd. dpair (suc dfst) (pair (ds {dfst} (fst dsnd))
        (reducer {dfst}{foldnat f m dfst} (fst dsnd) (snd dsnd))))))
    (dpair zero (pair dz base))))
  {zero} (\m _. DNat {m}) (\m. DNat {m}) {zero} const
  (\{a}{b} dn _. dn) dz dz
  (dpair zero (pair dz dz))

ifoldnat {\m. Vec {foldnat const zero m} Bit}{suc (suc zero)}
  (\{m} dn _. dn
    (\k. Vec {fst (k (Pair Nat Nat) (\p. pair (suc (fst p)) (fst p)) (pair zero zero))} Bit)
    (\v. vcons {Bit} I v) vnil)
  vnil (ds (ds dz))




let J : {A}(x y : A){p : Eq {A} x y} -> U
    = \{A} x y {p}. (B : {a : A} -> Eq {A} x a -> U) -> B refl -> B p;
let jrefl : {A x} -> J x x {refl} = \JI jr. jr;

\(x : Nat)(y : Nat)(p : Eq {Nat} x y){jp : J x y {p}}. tt (J (suc x) (suc y) {cong suc p}) (\JI jr. jp (\_. JI) jr)



let foldvec
    : {A : Nat -> U}{B n} -> ({m} -> B -> Vec {m} B -> A m -> A (suc m)) -> A zero -> Vec {n} B -> A n
    = \{A}{B}{n} reducer base v. snd (proj2 (v
        (\n. Sigma Nat (\n. Pair (Vec {n} B) (A n)) {n})
        (dpair zero (pair vnil base))
        (\{m} b s. s (\m. Sigma Nat (\n. Pair (Vec {n} B) (A n)) {suc m}) (\dfst dsnd. dpair
          (suc dfst) (pair (vcons b (fst dsnd)) (reducer b (fst dsnd) (snd dsnd)))))));

let foldltree
    : {A : Nat -> U}{B n} -> ({m} -> LTree {m} B -> LTree {m} B -> A m -> A m -> A (suc m)) -> (B -> A zero) -> LTree {n} B -> A n
    = \{A}{B}{n} reducer base tr. snd (proj2 (tr
        (\n. Sigma Nat (\n. Pair (LTree {n} B) (A n)) {n})
        (\a. dpair zero (pair (leaf a) (base a)))
        (\{m} sl sr. sl
          (\m. Sigma Nat (\n. Pair (LTree {n} B) (A n)) {suc m}) (\dfstl dsndl. sr
            (\_. Sigma Nat (\n. Pair (LTree {n} B) (A n)) {suc dfstl}) (\_ dsndr. dpair
              (suc dfstl) (pair
                (node (fst dsndl) (fst dsndr))
                (reducer (fst dsndl) (fst dsndr) (snd dsndl) (snd dsndr))))))));


let natIndInFst
    : {n : Nat}{ni : NatInd {n}}{A}{f : Nat -> A -> A}{a : A} ->
        Eq {Nat} (fst (n (Pair Nat A) (\p. pair (suc (fst p)) (f (fst p) (snd p))) (pair zero a))) n
    = \{n}{ni}. ni
        (\n. {A : U}{f : Nat -> A -> A}{a : A} -> Eq {Nat} (fst (n (Pair Nat A) (\p. pair (suc (fst p)) (f (fst p) (snd p))) (pair zero a))) n)
        (\{m}{A : U}{f : Nat -> A -> A}{a : A} acc. cong {Nat}{Nat}
          {fst (m (Pair Nat A) (\p. pair {Nat}{A} (suc (fst p)) (f (fst p) (snd p))) (pair {Nat}{A} zero a))}
          {m} suc acc) (\{A}{f}{a}. refl);
natIndInFst




let Alt : (U -> U) -> U
    = \F. {T} -> ({app : App F} -> (empty : {A} -> F A) -> (alt : {A} -> F A -> F A -> F A) -> F T) -> F T;
let maybeAlt : Alt Maybe
    = \A. A nothing (\lm rm. lm _ (rm _ nothing just) just);
let contMaybeAlt : {B} -> Alt (\W. Cont W (Maybe B))
    = \A. A {contApp} (cont (\k. k nothing))
        (\lcm rcm. maybeAlt (\empty alt. alt (run lcm id) (run rcm id)));
run (contMaybeAlt {Nat} (\{app} empty alt. app (\pure ap. alt (pure (just zero)) (pure (just (suc zero)))))) id


let contMaybeApp : {W} -> App (\B. Cont (Maybe W) (Maybe B))
    = \A. A (\x. cont (\k. k (just x))) (\cmf cma. cont (\k. run cma (\mv. mv _ (k nothing) (\v. run cmf (\mf. mf _ (k nothing) (\f. k (just (f v))))))));
run {Maybe Bit} (contMaybeApp (\pure ap. ap (pure not) (cont (\k. k nothing)))) id


-- contTrav does not exist
let contTrav : {W} -> Trav (Cont W)
    = \{W} T. T (\{G}{app}{B} f ca. app {Cont W B} (\pure ap. ca (G (Cont W B))
        (\k. ap (pure cont) (pure (\g. ap (pure k) (pure (\x. ap (pure g) (f x))))))));
contTrav

let contTrav : {W} -> Trav (Cont W)
    = \{W} T. T (\{G}{app}{B}{A} f ca. app {Cont W B} (\pure ap. run {G (Cont W B)}{A} ca
        (\(x : A). ap {(B -> W) -> W}{Cont W B} (pure cont) (ap {B}{(B -> W) -> W} (pure (\b g. g b)) (f x)))));
let contTrav : {W} -> Traversable (Cont W)
    = \{W} T. T (\{G}{app}{B}{A} f ca. app {Cont W B} (\pure ap. ap {(A -> Cont W B)}{Cont W B}
        (ap {Cont W A}{(A -> Cont W B) -> Cont W B} (pure run) (pure ca))
        (ap {(B -> W) -> W}{Cont W B} (pure cont) (f x))));





let buildTree : List Bit -> Maybe (RTree Unit)
    = \bs. (bs (Maybe (Nonempty (RTree Unit -> RTree Unit))) (just (sing id))
        (\b mfs. mfs (Maybe (Nonempty (RTree Unit -> RTree Unit))) nothing
            (\fs. fs (Maybe (Nonempty (RTree Unit -> RTree Unit)))
                (\f. b (Maybe (Nonempty (RTree Unit -> RTree Unit))) (just (ncons (\t. rnode (rleaf tt rnil) t) (sing f))) nothing)
                (\f mgs. b (Maybe (Nonempty (RTree Unit -> RTree Unit)))
                    (just (ncons (\t. rnode (rleaf tt rnil) t) (ncons f n)))
                    (just (n (Nonempty (RTree Unit -> RTree Unit)) (\g. sing (comp f g))
                        (\g o. ncons (comp f g) o)))))))
        (Maybe (RTree Unit)) (\f. just (f rnil)) (\_ _. nothing);
buildTree (cons O nil)

let buildTree : List Bit -> Maybe (RTree Unit)
    = \bs. (bs (Maybe (Nonempty (RTree Unit))) (just (sing id))
        (\b mfs. mfs (Maybe (Nonempty (RTree Unit))) nothing
            (\fs. fs (Maybe (Nonempty (RTree Unit)))
                (\f. b (Maybe (Nonempty (RTree Unit))) (just (ncons (\t. rnode (rleaf tt rnil) t) (sing f))) nothing)
                (\f mgs. b (Maybe (Nonempty (RTree Unit)))
                    (just (ncons (\t. rnode (rleaf tt rnil) t) (ncons f n)))
                    (just (n (Nonempty (RTree Unit)) (\g. sing (comp f g))
                        (\g o. ncons (comp f g) o)))))))
        (Maybe (RTree Unit)) just (\_ _. nothing);
buildTree (cons O nil)



let buildTree : List Bit -> Maybe (RTree Unit)
    = \bs. (snd (bs (Nonempty (Endo (Maybe (RTree Unit))))
        (sing id)
        (\b mfs. mfs (Nonempty (Endo (Maybe (RTree Unit))))
            (\f. _)
            (\f fs. _))))
        (Maybe (RTree Unit)) nothing (\f. f (just (rleaf tt)));
buildTree (nil)



let ratio : (n d : Nat) -> {_ : NonZero d} -> Coprime n d -> Ratio
    = \n d coprime R. R n d coprime;
ratio


let traverse : {G : U -> U}{tra : Trav G}{H : U -> U}{app : App H}{B A} ->
    (A -> H B) -> G A -> H (G B)
        = \{G}{tra}{H}{app}{B}{A} f ma. tra {H}{B} (\trav. trav {H}{app}{B}{A} f ma);
let listOfNonzero : Nat -> List Nat = \n. n (List Nat) (\_. cons n nil) nil;
traverse {Maybe}{maybeTrav}{List}{listApp}{Nat}{Nat} listOfNonzero (just (suc zero))