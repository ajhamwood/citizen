---------------------
-- prelude attempt --
---------------------


let Bit : U
    = {B} -> B -> B -> B;
let I : Bit
    = \i o. i;
let O : Bit
    = \i o. o;

let and : Bit -> Bit -> Bit
    = \x y i o. x (y i o) (x i o);
let or : Bit -> Bit -> Bit
    = \x y i o. x (x i o) (y i o);
let xor : Bit -> Bit -> Bit
    = \x y i o. x (y o i) (y i o);
let carry : Bit -> Bit -> Bit -> Bit
    = \a b c. or (and a b) (and c (xor a b));
let sum : Bit -> Bit -> Bit -> Bit
    = \a b c. xor (xor a b) c;

let Pair : {P} -> U -> U -> U
    = \{P} A B. (A -> B -> P) -> P;
let pair : {A B P} -> A -> B -> Pair {P} A B
    = \a b p. p a b;

(\a b c. pair (carry a b c) (sum a b c)) I I O


---------------------------------------------
-- BUG: does nothing with postponed checks --
---------------------------------------------


let List   : U -> U                       = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil    : {A} -> List A                = \L n c. n;
let cons   : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let Bool   : U                            = (B : U) -> B -> B -> B;
let true   : Bool                         = \b t f. t;
let Pair   : U -> U -> U                  = \A B. (P : U) -> (A -> B -> P) -> P;
let pair   : {A B} -> A -> B -> Pair A B  = \a b P p. p a b;
let Nat    : U                            = (N : U) -> (N -> N) -> N -> N;
let zero   : Nat                          = \N s z. z;
let map    : {A B} -> (A -> B) -> List A -> List B = \f as L n c. as L n (\a. c (f a));
let Id     : U -> U                       = \A. (I : U) -> (A -> I) -> I;
let mkId   : {A} -> A -> Id A             = \a I f. f a;
let unId   : {A} -> Id A -> A             = \i. i _ (\x. x);
let IdTy   : U                            = {A} -> A -> A;
let single : {A} -> A -> List A           = \a. cons a nil;
let id     : {A} -> A -> A                = \a. a;
let oneId  : Id IdTy                      = mkId id;
let poly   : IdTy -> Pair Nat Bool        = \f. pair (f zero) (f true);

let C9 = map poly (single id);
let C10 = map unId (single oneId);

C9
