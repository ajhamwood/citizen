let Wrap : U -> U                       = \A. (W : U) -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A           = \a W w. w a;
let unwrap : {A} -> Wrap A -> A         = \w. w _ (\x. x);

let Nat : U                             = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                          = \N s z. z;
let suc : Nat -> Nat                    = \n N s z. s (n N s z);

let Vec : {n} -> U -> U
    = \{n} A. (V : Nat -> U) -> V zero -> ({m : Nat} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A
    = \V n c. n;
let cons : {n A} -> A -> Vec {n} A -> Vec {suc n} A
    = \a as V n c. c a (as V n c);



let Bit : U                             = {B} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let not : Bit -> Bit                    = \b i o. b o i;

let Maybe : U -> U                      = \A. {M} -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A            = \n j. n;
let just : {A} -> A -> Maybe A          = \a n j. j a;

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeFunctor : Functor Maybe
    = \f. f (\fn ma n j. ma n (\a. j (fn a)));

maybeFunctor (\map. map not (just O))



let Bit : U                             = {B} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let Nat : U                             = {N} -> (N -> N) -> N -> N;
let zero : Nat                          = \s z. z;
let suc : Nat -> Nat                    = \n s z. s (n s z);

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> LTree {zero} A
    = \a b T l n. l a b;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);
-- eliminators

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let ltreeFunctor : Functor LTree
    = \f. f (\fn ta T l n. ta T (\a b. l (fn a) (fn b)) n);

let mapltree : {A B n} -> (A -> B) -> LTree {n} A -> LTree {n} B
    = \{A}{B} fn ltree. ltree (\n. LTree {n} B) (\a b. leaf (fn a) (fn b)) node;

let someltree : LTree Bit
    = node (node (leaf O I) (leaf I O)) (node (leaf I O) (leaf O I));
mapltree not someltree



let Bit : U                             = {B : U} -> B -> B -> B;
let I : Bit                             = \i o. i;
let O : Bit                             = \i o. o;

let Pair : U -> U -> U                  = \A B. {P} -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B  = \a b p. p a b;
let fst : {A B} -> Pair A B -> A        = \s. s (\a b. a);
let snd : {A B} -> Pair A B -> B        = \s. s (\a b. b);

let Nat : U                             = {N} -> (N -> N) -> N -> N;
let zero : Nat                          = \s z. z;
let suc : Nat -> Nat                    = \n s z. s (n s z);

let mul : Nat -> Nat -> Nat = \a b s z. a (b s) z;
let eqz : Nat -> Bit = \n. n (\z i o. o) (\i o. i);
let pred : Nat -> Nat =
    \n. snd {Nat} (n (\p. pair (suc (fst p)) (fst p)) (pair zero zero));

let fold : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat}
        (n {Pair Nat A} (\p. pair (suc (fst p)) (p reducer)) (pair zero base));

let fact : Nat -> Nat
    = \n. fold {Nat} (\k acc. mul acc (suc k)) (suc zero) n;

fact (suc (suc (suc zero)))



-- Dependently Typed Folds for Nested Data Types, Peng Fu and Peter Selinger
let Bush : {n} -> U -> U
    = \{n} A. (B : Nat -> U) -> (A -> B zero) -> ({n} -> B (suc n)) ->
        ({n} -> B n -> B (suc (suc n)) -> B (suc n)) -> B n;
let bbase : {A} -> A -> Bush {zero} A
    = \a B b n c. b a;
let bnil : {n A} -> Bush {suc n} A
    = \B b n c. n;
let bcons : {n A} -> Bush {n} A -> Bush {suc (suc n)} A -> Bush {suc n} A
    = \x xs B b n c. c (x B b n c) (xs B b n c);

let foldbush : {A} -> (B : Nat -> U) -> (A -> B zero) ->
               ({n} -> B (suc n)) -> ({n} -> B n -> B (suc (suc n)) -> B (suc n)) ->
               {n} -> Bush {n} A -> B n
    = \B b n c bush. bush B b n c;

let mapbush : {A B n} -> (A -> B) -> Bush {n} A -> Bush {n} B
    = \{A}{B} fn. foldbush {A} (\n. Bush {n} B) (\x. bbase (fn x)) bnil bcons;

-- [ O,
--   [ I, [ I ] ],
--   [ [ O ] ] ]
let somebush : Bush Bit
    = bcons (bbase O) (bcons
            (bcons (bbase I) (bcons
                   (bcons (bbase I) bnil)
                   bnil)) (bcons
            (bcons (bcons (bbase O) bnil)
                   bnil)
            bnil));
            
mapbush not somebush



let Nonempty : U -> U                   = \A. {N} -> (A -> N) -> (A -> N -> N) -> N;
let sing : {A} -> A -> Nonempty A       = \a s c. s a;
let cons : {A} -> A -> Nonempty A -> Nonempty A = \a as s c. c a (as s c);

let Monoid : U -> U                     = \A. {M} -> (neut : M) -> (comb : A -> M -> M) -> M;
let neut : {A} -> Monoid A              = \n c. n;
let comb : {A} -> A -> Monoid A -> Monoid A = \a as n c. c a (as n c);

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeFunctor : Functor Maybe
    = \F. F (\fn ma n j. ma n (\a. j (fn a)));

let Foldable : (U -> U) -> U
    = \(F : U -> U). {T}{super : Functor F}{A W} ->
                     ((foldmap : {MonW : Monoid W} -> (A -> W) -> F A -> W) -> F T) -> F T;
-- let fold : {W}{F : U -> U}{FoldF : Foldable F}{MonW : Monoid W} -> F W -> W
--     = foldmap (\x. x);

let maybeFoldable : Foldable Maybe
    = \{super=super}{A=A}{W=W} f. f (\{MonW=maybeMonoid} fn ma. ma {Maybe A} nothing (\x. just (fn x)));
maybeFoldable {maybeFunctor} (\foldmap. foldmap not (just O))


let Monoid : U -> U
    = \M. ({A} -> (neut : M) -> (comb : A -> M -> M) -> M) -> M;
let maybeMonoid : {A} -> Monoid (Maybe A)
    = \{A=A} f. f {A} nothing (\a _. just a);

-- maybeMonoid {Bit} (\n c. n)
maybeMonoid {Bit} (\n c. c I _)



let Nat : U                             = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                          = \N s z. z;
let suc : Nat -> Nat                    = \n N s z. s (n N s z);

let DNat : Nat -> U                     = \n. (DN : Nat -> U) -> ({m} -> DN m -> DN (suc m)) -> DN zero -> DN n;
let dz : DNat zero                      = \DN s z. z;
let dsuc : {m : Nat} -> DNat m -> DNat (suc m) = \n DN s z. s (n DN s z);

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> LTree {zero} A
    = \a b T l n. l a b;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);

let initWord : {n} -> DNat n -> LTree {n} Bit
    = \dn. dn (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O O);
initWord (dsuc (dsuc dz))



let bitAdd : Bit -> Bit -> Bit -> Pair Bit Bit
    = \a b c. pair (carry a b c) (sum a b c);

let addWithCarry : {n} -> LTree {n} Bit -> LTree {n} Bit -> Pair Bit (LTree {n} Bit)
    = \ta tb. x;
let word0 = leaf O I;
let word1 = leaf I I;
addWithCarry word0 word1



let head : {A n} -> Vec {suc n} A -> A  = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);
-- tail (cons I (cons O nil))

let getBit : {n} -> LTree {n} Bit -> Vec {suc n} Bit -> Bit
    = \{n} ltree vec. fst ((tail vec) (\k. Pair Bit (LTree {sub n k} Bit))
        (pair (head vec) ltree) (\{k} bit acc. (snd acc) _
            (\a b. pair (bit _ a b) (initWord dz))
            (\ta tb. pair bit (bit _ ta tb))));
let addr : Vec {suc zero} Bit
    = cons O nil;
let word0 : LTree {zero} Bit
    = leaf O I;
getBit word0 addr


(\n. addr (\k. (sub (suc n) k) _ (\_. LTree {sub n k} Bit) Bit)
    word0 (\{k} bit acc. acc ((sub (suc n) k) _ (\_. LTree {sub n k} Bit) Bit) (\a b. bit Bit a b) (\ta tb. bit (Tree {sub n k} Bit) ta tb))) zero



let LC : U = {R} -> (L : (R -> R) -> R) -> (A : R -> R -> R) -> R;
let id : LC = \l a. l (\x. x);
let comp : LC = \l a. l (\g. l (\f. l (\x. a g (a f x))));
let delta : LC = \l a. l (\x. a x x);
let omega : LC = \l a. a (l (\x. a x x)) (l (\x. a x x));
let z : LC = \l a. l (\s. l (\z. a s z));
let s : LC = \l a. l (\n. l (\s. l (\z. a s (a (a n s) z))));



let Either : U -> U -> U                = \A B. (E : U) -> (A -> E) -> (B -> E) -> E;
let left : {A B} -> A -> Either A B     = \a E l r. l a;
let right : {A B} -> B -> Either A B    = \b E l r. r b;
-- let resolve : {A B}{C : Either A B -> U} -> ((a : A) -> C (left a)) -> ((b : B) -> C (right b)) ->
--               (e : Either A B) -> C e
--     = \{C=C} f g e. e (C e) f g;

let Void : U                            = (V : U) -> V;
let absurd : {A} -> Void -> A           = \v. _;
let neg : U -> U                        = \P. P -> Void;
let Dec : U -> U                        = \P. Either P (neg P);
let Decidable : {A B} -> (A -> B -> U) -> U = \{A}{B} p. (x : A) -> (y : B) -> Dec (p x y);

let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A
    = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A
    = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);
let divine : {A} -> LTree {zero} A -> A
    = \{A} t. t (\_. A) (\a. a) _;
-- divine (leaf O)
-- lbranch (node (leaf O) (leaf I))

let getBit : {n} -> LTree {n} Bit -> Vec {n} Bit -> Bit
    = \{n} ltree vec. divine (vec (\k. LTree {sub n k} Bit) ltree
        (\{k} bit acc. bit (LTree {sub n k} Bit) (lbranch {Bit}{sub n k} acc) (rbranch {Bit}{sub n k} acc)));
getBit word0 addr



-- Bit addressing

let getBit : {n} -> LTree {n} Bit -> Vec {n} Bit -> LTree {zero} Bit
    = \{n} ltree vec. snd (vec (\k. Pair Nat (LTree {sub n k} Bit)) (pair n ltree)
        (\{k} bit acc. pair (pred (fst acc))
            (bit (LTree {sub n k} Bit)
                ((snd acc) (\_. LTree {sub n k} Bit) _ (\ta tb. ta))
                ((snd acc) (\_. LTree {sub n k} Bit) _ (\ta tb. tb)))));
-- bit (Pair Nat (LTree {fst acc} Bit)) (lbranch {Bit}{fst acc} (snd acc)) (rbranch {Bit}{fst acc} (snd acc))

let addr : Vec {suc zero} Bit
    = cons O nil;
let word0 : LTree {suc zero} Bit
    = node (leaf O) (leaf O);
getBit word0 addr



let Cont : U -> U -> U                  = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W = \c f. c _ (\k. k f);
let reset : {W} -> Cont W W -> W        = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));

let add : Nat -> Nat -> Nat             = \a b N s z. a N s (b N s z);
let addcps : Nat -> Nat -> Cont Nat Nat = \a b. cont (\k. k (add a b));
let test : Nat -> Nat -> Cont Nat Nat   = \a b. cont (\k. run (addcps a b) (\v. run (addcps a v) k));
run (test (suc (suc zero)) (suc zero)) (\x. x)


-- Monads

let Monad : (U -> U) -> U
    = \(M : U -> U). {T} -> ((return : {A} -> A -> M A) ->
                     (bind : {A B} -> M A -> (A -> M B) -> M B) -> M T) -> M T;
let contMonad : {W} -> Monad (Cont W)
    = \M. M (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));


let List : U -> U                       = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                = \L n c. n;
let cons : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let concat : {A} -> List A -> List A -> List A      = \{A} la lb. la (List A) lb cons;
let listFunctor : Functor List                      = \F. F (\fn la L n c. la L n (\a as. c (fn a) as));

let mapM : {A B}{M : U -> U}{monad : Monad M} -> (A -> M B) -> List A -> M (List B)
    = (\{A}{B}{M}{monad} f as. monad
        (\return bind. as (M (List B)) (return nil)
            (\a r. bind {B}{List B} (f a) (\x. bind {List B}{List B} r (\xs. return (cons x xs))))));
run {List Bit} (mapM {monad=contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)



let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
                     (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;
let appFunctor : {X} -> App X -> Functor X
    = \app F. F (\{A}{B} fn fa. app (\pure ap. ap {A}{B} (pure fn) fa));
let listApp : App List                              = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (listFunctor (\map. map f xs)) bs));
let appComp : {F G : U -> U} -> App F -> App G -> App (\X. G (F X))
    = \{F}{G} appF appG A. A
        (\{X} x. appG {F X} (\pureG apG. pureG (appF {X} (\pureF apF. pureF x))))
        (\f x. (appFunctor appF) (\map. appG (\{X}{Y} pureG apG. map {X}{Y} apG (appF {X} (\pureF apF. apF {X}{Y})) f) s));
(appComp listApp listApp) (\pure ap. ap
    (cons (cons not nil) nil)
    (cons (cons O (cons I nil)) (cons (cons I nil) nil)))

let Trav : (U -> U) -> U
    = \(F : U -> U). {T} -> ((traverse : {G : U -> U}{A B}{app : App G} -> (A -> G B) -> F A -> G (F B)) -> F T) -> F T;


-- Finite sets

let Fin : {n} -> U                                  = \{n}. (F : Nat -> U) -> ({m} -> F m -> F (suc m)) -> ({m} -> F (suc m)) -> F n;
let fz : {n} -> Fin {suc n}                         = \F s z. z;
let fs : {n} -> Fin {n} -> Fin {suc n}              = \f F s z. s (f F s z);

let lookup : {A n} -> Fin {n} -> Vec {n} A -> A
--    = \{A} f v. v (\_. A) _ (\a as. f _ (\_. as) a);
    = \{A}{m} f V n c. snd {Nat} (f (\_. Pair Nat A) (\p. pair (suc (fst p)) (p c)) (pair zero n));
lookup (cons O (cons I nil)) (fs fz)



-- Dependent Sums (not possible)

let Sigma : (A : U) -> (A -> U) -> {a} -> U          = \A B {a}. (P : A -> U) -> ((a : A) -> B a -> P a) -> P a;
let sigma : {A}{B : A -> U} -> (a : A) -> B a -> Sigma A B = \a b P p. p a b;
let dfst : {A}{B : A -> U} -> Sigma A B -> A         = \{A=A} s. s _ (\a b. a);
let dsnd : {A}{B : A -> U} -> (p : Sigma A B) -> B (dfst p) = \{B=B} s. s _ (\a b. b);

-- Dependent Sums

let Sigma : (A : U) -> (A -> U) -> U =
    \A B. (fst : A) -> (snd : B fst) -> (S : (A : U) -> (A -> U) -> U) -> (s : (a : A) -> B a -> S A B) ->
      S A B;
let sigma : {A}{B : A -> U} -> Sigma A B = \a b S s. s a b;
the (Sigma Bit (\_. Bit)) (sigma O I)


run {Fin {suc (suc zero)}}{Fin {suc (suc zero)}} (somefin (\n. Cont (Fin {n}) (Fin {n})) (\{n} f. cont (\k. k (run {Fin {suc n}}{Fin {n}} (cont (\k. k (run f (\x. x)))) fs))) (\{n}. cont (\k. k fz))) (\x. x)

run {Vec {suc (suc zero)} Bit}{Vec {suc (suc zero)} Bit}
    (somevec
        (\n. Cont (Vec {n} Bit) (Vec {n} Bit))
        (cont (\k. k nil))
        (\{n} a as. cont (\k. k (run
            {Vec {suc n} Bit}{Vec {n} Bit}
            (cont (\k. k (run as (\x. x))))
            (cons a)))))
    (\x. x)

(the
    ({n : Nat} -> Bit -> Cont (Vec {suc n} Bit) (Vec {n} Bit) -> Cont (Vec {suc n} Bit) (Vec {suc n} Bit))
    (\{n} a as. cont
        {Vec {suc n} Bit}{Vec {suc n} Bit}
        (\k. k (run
            {Vec {suc n} Bit}{Vec {n} Bit} as (cons a)))))
{zero} I (cont (\k. k nil))



run {Vec {suc (suc zero)} Bit}{Vec {zero} Bit -> Vec {suc (suc zero)} Bit}
    (somevec
        (\n. Cont (Vec {zero} Bit -> Vec {n} Bit) (Vec {zero} Bit -> Vec {n} Bit))
        (cont (\k. k (\x. x)))
        (\{n} a as. cont (\k. k (run
            {Vec {zero} Bit -> Vec {suc n} Bit}{Vec {zero} Bit -> Vec {n} Bit}
            (cont (\k. k (run as (cons a))))
            (\x. x)))))
    (\k. k nil)


run
    {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
    {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
    (cont
        {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
        {{n} -> Vec {n} Bit -> Vec {n} Bit}
        (\k {n} (v : Vec {n} Bit). k (\w. w) v))
    (cons a)


run
            {{n} -> Vec {n} Bit -> Vec {suc n} Bit}
            {{n} -> Vec {n} Bit -> Vec {n} Bit}
            (cont
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                (\q. run (cont (\k. k (\x. x))) (q (\x. x))))
            ((\x. x) (cons I))
nil

run (somevec
    _
    (cont (\k. k (\x. x)))
    (\{n} a as. cont
        (\k. run (cont
            (\q. run as (q (cons a)))) (k (\x. x)))))
(\f. f nil)
                
cont
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                {{n} -> Vec {n} Bit -> Vec {n} Bit}
                (\q. run (cont (\k. k (\x. x))) (q (\x. x)))

let fold : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A) (\p. pair (suc (fst p)) (p reducer)) (pair zero base));


nil => base, O : nil => f O base, I : O : nil => f I (f O base)
nil => base, O : nil => f base O, I : O : nil => f (f base O) I

let foldvec : {A n} -> ({m} -> Vec {suc m} A -> A -> A) -> A -> Vec {n} A -> A
    = \{A}{n} reducer base v. snd {Vec {n} A} (v
        (\n. Pair (Vec {n} A) A)
        (pair nil base)
        (\a p. pair (cons a (fst p)) (p A (\v. reducer (cons a v)))));
foldvec {Bit} (\v acc. or acc (head v)) O (cons I (cons O nil))

foldtree {Bit} (\b. b) (\lt acc. acc) (\lt acc. acc) sometree

let dfoldvec : {A}{B : Nat -> U}{n} -> ({m} -> Vec {suc m} A -> B m -> B (suc m)) -> B zero -> Vec {n} A -> B n
    = \{A}{B}{n} reducer base v. snd {Vec {n} A} (v
        (\n. Pair (Vec {n} A) (B n))
        (pair nil base)
        (\{m} a p. pair (cons a (fst p)) (p (B (suc m)) (\v. reducer {m} (cons a v)))));
dfoldvec {Bit}{\n. LTree {n} Bit -> Bit}
    (\{m} v acc lt. acc ((head v) (LTree {suc m} Bit -> LTree {m} Bit) (lbranch {Bit}) (rbranch {Bit}) lt))
    divine somevec sometree

let dfoldfin : {A : Nat -> U}{n} -> ({m} -> Fin {suc m} -> A m -> A (suc m)) -> ({m} -> A (suc m)) -> Fin {suc n} -> A (suc n)
    = \{A}{n} reducer base fn. snd {Fin {suc n}} (fn
        (\n. Pair (Fin {n}) (A n))
        (\{m} p. pair (fs (fst p)) (p (A (suc m)) (\f. reducer {m} (fs f))))
        (\{m}. pair fz (base {m})));
dfoldfin {\_. Bit} (\fn acc. not acc) O (fs (fs fz))


(O (LTree Bit -> LTree Bit) (lbranch {Bit}{zero}) (rbranch {Bit}{zero})) (node (leaf I) (leaf O))
divine (lbranch {Bit}{zero} (node (leaf I) (leaf O)))



dfoldfin {Bit}
    (\{m} fn acc v. acc (fn (\n. Vec {n} Bit) tail v))
    head fz (cons O nil)



let lookup : {A}{n} ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A -> A) ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A) ->
    Pair (Vec {suc n} A) (Fin {suc n}) -> A
    = \{A}{n} reducer base p. snd {Pair (Vec {suc n} A) (Fin {suc n})} (p A (\v fn. pair
        (v _ _ _)
        (fn _ _ _)));

let lookup : {A n} ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A -> A) ->
    ({m} -> Pair (Vec {suc m} A) (Fin {suc m}) -> A) ->
    Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} reducer base v fn. snd {Pair (Vec {suc n} A) (Fin {suc n})} (pair
        (reducer)
        (base));

let lookup : {A n} -> Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} v fn. fn (\_. A) _ (head v);
lookup {Bit} (cons O nil) fz

let foldlookup : {A n} ->
    ({m} -> Pair (Fin {suc m}) (Vec {suc m} A) -> Pair (Fin {m}) (Vec {m} A) -> Pair (Fin {suc m}) (Vec {suc m} A)) ->
    ({m} -> Pair (Fin {suc m}) (Vec {suc m} A)) -> Vec {suc n} A -> Fin {suc n} -> A
    = \{A}{n} reducer base v fn. head (snd {Fin {suc n}} (fn
        (\n. Pair (Fin {n}) (Vec {n} A))
        (\{m} f p. p (Pair (Fin {suc m}) (Vec {suc m} A)) (\fn v. reducer {m} (pair (fs fn) (cons a v)) (pair fn v)))
        (\{m}. pair fz (base {m}))));
foldlookup {Bit}{\n. Pair (Fin {n}) (Vec {n} A)}
    (\v acc. or acc (head v)) O (cons I (cons O nil))


foldvec {Bit}{\n. Fin {suc n}} (\v acc. if (head v) acc (fs acc)) fz (cons I (cons O nil))


let Reflects : U -> Bit -> U                          = \P b. (R : Bit -> U) -> (P -> R I) -> (neg P -> R O) -> R b;
let ofyes : {P} -> P -> Reflects P I                  = \p R y n. y p;
let ofno : {P} -> neg P -> Reflects P O               = \negp R y n. n negp;

let of : {P}{b : Bit} -> b U P (neg P) -> Reflects P b
    = \{P}{b} p. b (Reflects P b) (the (Reflects P I) (ofyes p)) (ofno p);


let of : {P}{b : Bit} -> Either (P -> Reflects P I) ((neg P) -> Reflects P O)
    = \{P}{b}. b (_) (left ofyes) (right ofno);

let of : {P}{b : Bit} -> Either P (neg P) -> Reflects P b
    = \{P}{b} e. e (Reflects P b) (ofyes) (ofno);


someDNatPair (Fin {suc (suc zero)}) (\a b.
    (\n. b (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n}))
    (a _ suc zero))

the (Fin {suc zero}) ((\n. dz (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n})) zero)
(\n. dz (\m. Fin {suc (add m n)}) (\{m} acc. fs {suc (add m n)} acc) (fz {n})) zero

the (Fin {suc zero}) ((\n. dz (\m. Fin {suc (add m n)}) fs fz) zero)



-- Identity index

let Wrap : {T} -> T -> U                              = \{T} t. (W : {T} -> T -> U) -> ({V} -> (v : V) -> W {V} v) -> W {T} t;
let wrap : {T} -> (t : T) -> Wrap {T} t               = \{V} v W w. w {V} v;
let unwrap : {T t} -> Wrap {T} t -> T                 = \{V}{v} w. w (\_. V) (\_. v);

tt (Wrap tt) ((\t. tt (Wrap {Unit} t) (wrap t)) tt)