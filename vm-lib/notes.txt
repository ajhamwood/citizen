---------------------
-- prelude attempt --
---------------------


let Nat : U    = {N} -> N -> (N -> N) -> N;
let zero : Nat = \z s. z;
let suc : Nat -> Nat = \n z s. s (n z s);

let Bit : U    = {B} -> B -> B -> B;
let I : Bit    = \i o. i;
let O : Bit    = \i o. o;

let Tree : {n} -> U -> U
    = \{n} A. (T: Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> Tree {zero} A
    = \a b T l n. l a b;
let node : {n A} -> Tree {n} A -> Tree {n} A -> Tree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);

-- node (node (leaf I O) (leaf O I)) (node (leaf O I) (leaf I O))

let initWord : (m : Nat) -> Tree {m} Bit
    = \m. m (leaf {A=Bit} O O) (\k. node {A=Bit} (initWord k) (initWord k));

initWord (suc zero)


---------------------------------------------
-- BUG: does nothing with postponed checks --
---------------------------------------------


let List   : U -> U                       = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil    : {A} -> List A                = \L n c. n;
let cons   : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let Bool   : U                            = (B : U) -> B -> B -> B;
let true   : Bool                         = \b t f. t;
let Pair   : U -> U -> U                  = \A B. (P : U) -> (A -> B -> P) -> P;
let pair   : {A B} -> A -> B -> Pair A B  = \a b P p. p a b;
let Nat    : U                            = (N : U) -> (N -> N) -> N -> N;
let zero   : Nat                          = \N s z. z;
let map    : {A B} -> (A -> B) -> List A -> List B = \f as L n c. as L n (\a. c (f a));
let Id     : U -> U                       = \A. (I : U) -> (A -> I) -> I;
let mkId   : {A} -> A -> Id A             = \a I f. f a;
let unId   : {A} -> Id A -> A             = \i. i _ (\x. x);
let IdTy   : U                            = {A} -> A -> A;
let single : {A} -> A -> List A           = \a. cons a nil;
let id     : {A} -> A -> A                = \a. a;
let oneId  : Id IdTy                      = mkId id;
let poly   : IdTy -> Pair Nat Bool        = \f. pair (f zero) (f true);

let C9 = map poly (single id);
let C10 = map unId (single oneId);

C9
