let List   : U -> U                       = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil    : {A} -> List A                = \L n c. n;
let cons   : {A} -> A -> List A -> List A = \a as L n c. c a (as L n c);
let Bool   : U                            = (B : U) -> B -> B -> B;
let true   : Bool                         = \b t f. t;
let Pair   : U -> U -> U                  = \A B. (P : U) -> (A -> B -> P) -> P;
let pair   : {A B} -> A -> B -> Pair A B  = \a b P p. p a b;
let Nat    : U                            = (N : U) -> (N -> N) -> N -> N;
let zero   : Nat                          = \N s z. z;
let map    : {A B} -> (A -> B) -> List A -> List B = \f as L n c. as L n (\a. c (f a));
let Id     : U -> U                       = \A. (I : U) -> (A -> I) -> I;
let mkId   : {A} -> A -> Id A             = \a I f. f a;
let unId   : {A} -> Id A -> A             = \i. i _ (\x. x);
let IdTy   : U                            = {A} -> A -> A;
let single : {A} -> A -> List A           = \a. cons a nil;
let id     : {A} -> A -> A                = \a. a;
let oneId  : Id IdTy                      = mkId id;
let poly   : IdTy -> Pair Nat Bool        = \f. pair (f zero) (f true);

let C9 = map poly (single id);
let C10 = map unId (single oneId);

C9