let Bit : U
    = (B : U) -> B -> B -> B;
let I : Bit
    = \B i o. i;
let O : Bit
    = \B i o. o;

let not : Bit -> Bit
    = \b B i o. b B o i;

let Maybe : U -> U
    = \A. (M : U) -> M -> (A -> M) -> M;
let Nothing : {A} -> Maybe A
    = \M n j. n;
let Just : {A} -> A -> Maybe A
    = \a M n j. j a;

let Functor : (U -> U) -> U
    = \(F : U -> U). {T A} -> ((map : {B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeEndofunctor : Functor Maybe
    = \f. f (\fn ma M n j. ma M n (\x. j (fn x)));

maybeEndofunctor (\map. map not (Just O))