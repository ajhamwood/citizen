-- Unit

let Unit : U                                        = (T : U) -> T -> T;
let tt : Unit                                       = \T t. t;

-- Booleans

let Bit : U                                           = (B : U) -> B -> B -> B;
let I : Bit                                           = \B i o. i;
let O : Bit                                           = \B i o. o;
let not : Bit -> Bit                                  = \b B i o. b B o i;
let or : Bit -> Bit -> Bit                            = \x y B i o. x B (x B i o) (y B i o);

-- Products

let Pair : U -> U -> U                                = \A B. (P : U) -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B                = \a b P p. p a b;
let fst : {A B} -> Pair A B -> A                      = \s. s _ (\a b. a);
let snd : {A B} -> Pair A B -> B                      = \s. s _ (\a b. b);

-- Nats

let Nat : U                                           = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                                        = \N s z. z;
let suc : Nat -> Nat                                  = \n N s z. s (n N s z);
let add : Nat -> Nat -> Nat                           = \a b N s z. a N s (b N s z);

let pred : Nat -> Nat                                 = \n. snd {Nat} (n _ (\p. pair (suc (fst p)) (fst p)) (pair zero zero));
let minus : Nat -> Nat -> Nat                         = \m n. n _ pred m;


-- Equality

let Eq : {T} -> T -> T -> U = \{T} x y. (P : T -> U) -> P x -> P y;
let refl : {t} -> Eq t t = \P pt. pt;

-- Length-indexed Vectors

let Vec : {n} -> U -> U                               = \{n} A. (V : Nat -> U) -> V zero -> ({m} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A                         = \V n c. n;
let cons : {A n} -> A -> Vec {n} A -> Vec {suc n} A   = \a as V n c. c a (as V n c);
let head : {A n} -> Vec {suc n} A -> A                = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A        = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);

-- Height-indexed Binary Leaf-only Trees

let LTree : {n} -> U -> U                             = \{n} A. (T : Nat -> U) -> (A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> LTree {zero} A                 = \a T l n. l a;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A = \ta tb T l n. n (ta T l n) (tb T l n);
let divine : {A} -> LTree {zero} A -> A               = \{A} t. t (\_. A) (\a. a) _;
let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);


let lookupNat : {A m} -> Nat -> Vec {m} A -> A
    = \{A} n v. v (\_. A) _ (\{m} a acc. (add (minus m n) (minus n m)) A (\_. acc) a);
let lookupTree : {A n} -> Vec {n} Bit -> LTree {n} A -> A
    = \{A}{n} v tr. tr (\_. A) (\a. a) (\{m} l r. (lookupNat {m=n} m v) _ r l);

lookupTree {Bit} (cons I (cons O nil)) (node (node (leaf I) (leaf I)) (node (leaf O) (leaf I)))