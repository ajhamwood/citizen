let Wrap : U -> U
    = \A. {W} -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A
    = \a w. w a;
let unwrap : {A} -> Wrap A -> A
    = \w. w (\x. x);

let Nat : U    = (N : U) -> (N -> N) -> N -> N;
let zero : Nat = \N s z. z;
let suc : Nat -> Nat = \n N s z. s (n N s z);

let Vec : {n} -> U -> U
    = \{n} A. (V : Nat -> U) -> V zero -> ({m : Nat} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A
    = \V n c. n;
let cons : {n A} -> A -> Vec {n} A -> Vec {suc n} A
    = \a as V n c. c a (as V n c);



let Bit : U = {B} -> B -> B -> B;
let I : Bit = \i o. i;
let O : Bit = \i o. o;

let not : Bit -> Bit
    = \b i o. b o i;

let Maybe : U -> U
    = \A. {M} -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A
    = \n j. n;
let just : {A} -> A -> Maybe A
    = \a n j. j a;

let Functor : (U -> U) -> U
    = \(F : U -> U). {T A} -> ((map : {B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeFunctor : Functor Maybe
    = \f. f (\fn ma n j. ma n (\x. j (fn x)));

maybeFunctor (\map. map not (just O))



let Bit : U = {B} -> B -> B -> B;
let I : Bit = \i o. i;
let O : Bit = \i o. o;

let Nat : U    = {N} -> (N -> N) -> N -> N;
let zero : Nat = \s z. z;
let suc : Nat -> Nat = \n s z. s (n s z);

let Tree : {n} -> U -> U
    = \{n} A. (T: Nat -> U) -> (A -> A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> A -> Tree {zero} A
    = \a b T l n. l a b;
let node : {n A} -> Tree {n} A -> Tree {n} A -> Tree {suc n} A
    = \ta tb T l n. n (ta T l n) (tb T l n);

let initWord : (n : Nat) -> Tree {n} Bit
    = \n. fold {Tree {n} Bit} (\k acc. node {k}{Bit} acc acc) (leaf {Bit} O O) n;
initWord (suc (suc zero))



let Bit : U = {B : U} -> B -> B -> B;
let I : Bit = \i o. i;
let O : Bit = \i o. o;

let Pair : U -> U -> U
    = \A B. {P} -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B
    = \a b p. p a b;
let fst : {A B} -> Pair A B -> A
    = \s. s (\a b. a);
let snd : {A B} -> Pair A B -> B
    = \s. s (\a b. b);

let Nat : U    = {N} -> (N -> N) -> N -> N;
let zero : Nat = \s z. z;
let suc : Nat -> Nat = \n s z. s (n s z);

let mul : Nat -> Nat -> Nat = \a b s z. a (b s) z;
let eqz : Nat -> Bit = \n. n (\z i o. o) (\i o. i);
let pred : Nat -> Nat =
    \n. snd {Nat} (n (\p. pair (suc (fst p)) (fst p)) (pair zero zero));

let fold : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} r base n. snd {Nat} (n {Pair Nat A}
        (\p. pair (suc (fst p)) (r (fst p) (snd p)))
        (pair zero base));

let fact : Nat -> Nat
    = \n. fold {Nat} (\k acc. mul acc (suc k)) (suc zero) n;

fact (suc (suc (suc zero)))