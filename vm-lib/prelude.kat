let Bit : U
    = {B} -> B -> B -> B;
let I : Bit
    = \i o. i;
let O : Bit
    = \i o. o;
let not : Bit -> Bit
    = \b i o. b o i;
let and : Bit -> Bit -> Bit
    = \x y i o. x (y i o) (x i o);
let or : Bit -> Bit -> Bit
    = \x y i o. x (x i o) (y i o);
let xor : Bit -> Bit -> Bit
    = \x y i o. x (y o i) (y i o);
let if : {R} -> Bit -> R -> R -> R
    = \p a b. p a b;

let Pair : {P} -> (A B : _) -> U
    = \{P} A B. A -> B -> (A -> B -> P) -> P;
let pair : {A B} -> Pair A B
    = \a b p. p a b;
let fst : {A B} -> (P : (A -> B -> A) -> A) -> A
    = \p. p (\a b. a);
let snd : {A B} -> (P : (A -> B -> B) -> B) -> B
    = \p. p (\a b. b);

fst (pair I O)

-- let bitAdd : Bit -> Bit -> Bit -> Pair Bit Bit
--     = \a b c. pair (xor (xor a b) c) (or (and a b) (and c (xor a b)));
-- bitAdd O O O