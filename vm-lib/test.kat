-- Unit

let Unit : U                                          = (T : U) -> T -> T;
let tt : Unit                                         = \T t. t;

-- Booleans

let Bit : U                                           = (B : U) -> B -> B -> B;
let I : Bit                                           = \B i o. i;
let O : Bit                                           = \B i o. o;
let not : Bit -> Bit                                  = \b B i o. b B o i;

-- Nats

let Nat : U                                           = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                                        = \N s z. z;
let suc : Nat -> Nat                                  = \n N s z. s (n N s z);

-- Maybe

let Maybe : U -> U                                    = \A. (M : U) -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A                          = \M n j. n;
let just : {A} -> A -> Maybe A                        = \a M n j. j a;

-- Lists

let List : U -> U                                     = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                              = \L n c. n;
let cons : {A} -> A -> List A -> List A               = \a as L n c. c a (as L n c);

-- Continuations

let Cont : U -> U -> U                                = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A       = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W          = \{W} c f. c W (\k. k f);
let reset : {W} -> Cont W W -> W                      = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));


-- Dependent Nats

let DNat : {n} -> U
    = \{n}. (DN : Nat -> U) -> ({m} -> DN m -> DN (suc m)) -> DN zero -> DN n;
let dz : DNat {zero}                                  = \DN s z. z;
let ds : {n} -> DNat {n} -> DNat {suc n}              = \n DN s z. s (n DN s z);

-- Height-indexed Binary Leaf-only Trees

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> LTree {zero} A                 = \a T l n. l a;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A = \ta tb T l n. n (ta T l n) (tb T l n);

let initWord : {n} -> DNat {n} -> LTree {n} Bit       = \dn. dn (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O);


-- Applicatives

let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
        (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;
let maybeApp : App Maybe
    = \A. A just (\mf ma M n j. mf M n (\f. ma M n (\x. j (f x))));

-- Monads

let Monad : (U -> U) -> U
    = \(F : U -> U). {T} -> ((return : {A} -> A -> F A) ->
        (bind : {A B} -> F A -> (A -> F B) -> F B) -> F T) -> F T;
let monadApp : {F} -> Monad F -> App F
    = \monad A. A (\x. monad (\return bind. return x))
        (\fs xs. monad (\return bind. bind fs (\f. bind xs (\x. return (f x)))));
let contMonad : {W} -> Monad (Cont W)
    = \F. F (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));

-- Traversables

let Trav : (F : U -> U) -> U
    = \F. {S : U -> U}{T} -> ((traverse : {G : U -> U}{app : App G}{B A} -> (A -> G B) -> F A -> G (F B)) -> S (F T)) -> S (F T);

let listTrav : Trav List
    = \T. T (\{app=app} f la. app (\pure ap. la _ (pure nil) (\a as. ap (ap (pure cons) (f a)) as)));

let ltreeTrav : {n} -> Trav (LTree {n})
    = \T. T (\{F}{app}{B} f ta. app (\pure ap. ta (\n. F (LTree {n} B))
        (\a. ap (pure leaf) (f a)) (\{m} l r. ap (ap (pure node) l) r)));
let maybeO : Bit -> Maybe Unit = \b. b (Maybe Unit) nothing (just tt);
--ltreeTrav {S=Maybe} (\traverse. traverse {app=maybeApp} maybeO (initWord (ds (ds dz))))

let mapM : {T}{trav : Trav T}{M}{monad : Monad M}{A B} -> (A -> M B) -> T A -> M (T B)
    = \{T}{trav}{M}{monad}{A}{B} f as. trav {M}{B} (\traverse. traverse {M}{monadApp monad}{B}{A} f as);

run {List Bit} (mapM {List}{listTrav}{Cont}{contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)