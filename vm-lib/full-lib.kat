let id : {A} -> A -> A                                = \x. x;
let const : {A B} -> A -> B -> A                      = \x _. x;
let const2 : {A B} -> A -> B -> B                     = \_. id;

let dcomp : {A : U}{B : A -> U}{C : {x : A} -> B x -> U} ->
            ({x : A}(y : B x) -> C {x} y) -> (g : (x : A) -> B x) ->
            (x : A) -> C {x} (g x)
    = \f g x. f {x} (g x);
let comp : {A B C : U} -> (B -> C) -> (A -> B) -> A -> C  = \f g x. f (g x);

let dcomp2 : {A1 : U}{A2 : A1 -> U}{B : (x : A1) -> A2 x -> U}
             {C : {x : A1}{y : A2 x} -> B x y -> U} ->
             ({x : A1}{y : A2 x} -> (z : B x y) -> C {x}{y} z) ->
             (g : (x : A1) -> (y : A2 x) -> B x y) ->
             (x : A1) -> (y : A2 x) -> C {x}{y} (g x y)
    = \f g x y. f {x}{y} (g x y);
let comp2 : {A1 A2 B C : U} -> (B -> C) -> (A1 -> A2 -> B) -> A1 -> A2 -> C
    = \f g x y. f (g x y);

let flip : {A B}{C : A -> B -> U} -> ((x : A)(y : B) -> C x y) -> (y : B) -> (x : A) -> C x y
    = \f y x. f x y;
let pipe : {A : U}{B : A -> U} -> (a : A) -> ((a : A) -> B a) -> B a
    = \x f. f x;

let bincomp : {A B C D E : U} -> (A -> B -> C) -> (C -> D -> E) -> (A -> B -> D) -> (A -> B -> E)
    = \f star g x y. star (f x y) (g x y);

let leftbin : {A B C D : U} -> (A -> B -> C) -> (C -> B -> D) -> A -> B -> D
    = \{A}{B}{C}{D} f star. bincomp {A}{B}{C}{B}{D} f star (const2 {A}{B});
let rightbin : {A B C D : U} -> (A -> C -> D) -> (A -> B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star g. bincomp {A}{B}{A}{C}{D} (const {A}{B}) star g;

let leftun : {A B C D : U} -> (A -> C) -> (C -> B -> D) -> A -> B -> D
    = \{A}{B}{C}{D} f star. leftbin {A}{B}{C}{D} (dcomp2 {A}{\_. B}{\_ _.A}{\_. C} f (const {A}{B})) star;
let rightun : {A B C D : U} -> (A -> C -> D) -> (B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star g. rightbin {A}{B}{C}{D} star (dcomp2 {A}{\_. B}{\_ _. B}{\_. C} g (const2 {A}{B}));
let twoun : {A B C D E : U} -> (A -> C) -> (C -> D -> E) -> (B -> D) -> A -> B -> E
    = \{A}{B}{C}{D}{E} f star g. bincomp {A}{B}{C}{D}{E} (leftun {A}{B}{C}{C} f (const {C}{B})) star
      (rightun {A}{B}{D}{D} (const2 {A}{D}) g);

let on2 : {A B C D : U} -> (C -> C -> D) -> (A -> B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star f. bincomp f star f;
let on : {A B C : U} -> (B -> B -> C) -> (A -> B) -> A -> A -> C
    = \{A}{B}{C} star f. twoun f star f;


let on : {A B C : U} -> (B -> B -> C) -> (A -> B) -> A -> A -> C
    = \{A}{B}{C} star f x y. star (f x) (f y);


let typeof : {A} -> A -> U                            = \{A} a. A;



-- Void

let Void : U                                          = (V : U) -> V;
let absurd : {A} -> Void -> A                         = \V. _;


-- Unit

let Unit : U                                          = (T : U) -> T -> T;
let tt : Unit                                         = \T t. t;


-- Booleans

let Bit : U                                           = (B : U) -> B -> B -> B;
let I : Bit                                           = \B i o. i;
let O : Bit                                           = \B i o. o;
let not : Bit -> Bit                                  = \b B i o. b B o i;
let and : Bit -> Bit -> Bit                           = \x y B i o. x B (y B i o) (x B i o);
let or : Bit -> Bit -> Bit                            = \x y B i o. x B (x B i o) (y B i o);
let xor : Bit -> Bit -> Bit                           = \x y B i o. x B (y B o i) (y B i o);
let nand : Bit -> Bit -> Bit                          = \x y B i o. x B (y B o i) (x B o i);
let nor : Bit -> Bit -> Bit                           = \x y B i o. x B (x B o i) (y B o i);
let xnor : Bit -> Bit -> Bit                          = \x y B i o. x B (y B i o) (y B o i);
let if : {R} -> Bit -> R -> R -> R                    = \p a b. p _ a b;
let carry : Bit -> Bit -> Bit -> Bit                  = \a b c. or (and a b) (and c (xor a b));
let sum : Bit -> Bit -> Bit -> Bit                    = \a b c. xor (xor a b) c;


-- Nats

let Nat : U                                           = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                                        = \N s z. z;
let suc : Nat -> Nat                                  = \n N s z. s (n N s z);
let add : Nat -> Nat -> Nat                           = \a b N s z. a N s (b N s z);
let mul : Nat -> Nat -> Nat                           = \a b N s z. a N (b N s) z;
let pred : Nat -> Nat
    = \n. snd {Nat} (n _ (\p. pair (suc (fst p)) (fst p)) (pair zero zero));
let minus : Nat -> Nat -> Nat                         = \m n. n _ pred m;
let eqz : Nat -> Bit                                  = \n. n _ (\_. O) I;
let diff : Nat -> Nat -> Nat                          = \m n. add (minus m n) (minus n m);
let eqn : Nat -> Nat -> Bit                           = \m n. (diff m n) Bit (\_. O) I;

let foldnat : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A)
        (\p. pair (suc (fst p)) (p A (\m. reducer (suc m)))) (pair zero base));
let fact : Nat -> Nat = \n. foldnat {Nat} mul (suc zero) n;
-- fact (suc (suc (suc zero)))


-- Identity

let Wrap : U -> U                                     = \A. (W : U) -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A                         = \a W w. w a;
let unwrap : {A} -> Wrap A -> A                       = \{A} w. w A (\x. x);


-- Products

let Pair : U -> U -> U                                = \A B. (P : U) -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B                = \a b P p. p a b;
let fst : {A B} -> Pair A B -> A                      = \{A} s. s A (\a b. a);
let snd : {A B} -> Pair A B -> B                      = \{B=B} s. s B (\a b. b);


-- Maybe

let Maybe : U -> U                                    = \A. (M : U) -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A                          = \M n j. n;
let just : {A} -> A -> Maybe A                        = \a M n j. j a;


-- Either

let Either : U -> U -> U                              = \A B. (E : U) -> (A -> E) -> (B -> E) -> E;
let left : {A B} -> A -> Either A B                   = \a E l r. l a;
let right : {A B} -> B -> Either A B                  = \b E l r. r b;


-- Lists

let List : U -> U                                     = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                              = \L n c. n;
let cons : {A} -> A -> List A -> List A               = \a as L n c. c a (as L n c);
let concat : {A} -> List A -> List A -> List A        = \{A} la lb. la (List A) lb cons;


-- Non-empty list

let Nonempty : U -> U                                 = \A. (N : U) -> (A -> N) -> (A -> N -> N) -> N;
let sing : {A} -> A -> Nonempty A                     = \a N s c. s a;
let ncons : {A} -> A -> Nonempty A -> Nonempty A      = \a as N s c. c a (as N s c);

let nelToList : {A} -> Nonempty A -> List A           = \{A} nl. nl (List A) (\a. cons a nil) cons;


-- Continuations

let Cont : U -> U -> U                                = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A       = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W          = \{W} c f. c W (\k. k f);
let reset : {W} -> Cont W W -> W                      = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));



-- Dependent Identity

let DWrap : {T} -> T -> U                             = \{T} x. (W : T -> U) -> ((t : T) -> W t) -> W x;
let dwrap : {T} -> (t : T) -> DWrap {T} t             = \{V} v W w. w v;
let undwrap : {T t} -> DWrap {T} t -> T               = \{V}{v} w. w (\_. V) (\_. v);
-- tt (DWrap tt) ((\t. tt (DWrap {Unit} t) (dwrap t)) tt)


-- Leibniz Equality

let Eq : {T} -> T -> T -> U                           = \{T} x y. (P : T -> U) -> P x -> P y;
let refl : {T t} -> Eq {T} t t                        = \P pt. pt;
let trans : {T}{x y z : T} -> Eq x y -> Eq y z -> Eq x z = \xy yz P px. yz P (xy P px);
let sym : {T}{x y : T} -> Eq x y -> Eq {T} y x        = \{T}{x} xy P. xy (\z. P z -> P x) (refl {T} P);
let cong : {A B x y}(f : A -> B) -> Eq x y -> Eq {B} (f x) (f y) = \f xy P. xy (\x. P (f x));
let subst : {T}{x y : T}(P : T -> U) -> Eq x y -> P x -> P y = \P xy. xy P;


-- Dependent Nats

let DNat : {n} -> U
    = \{n}. (DN : Nat -> U) -> ({m} -> DN m -> DN (suc m)) -> DN zero -> DN n;
let dz : DNat {zero}                                  = \DN s z. z;
let ds : {n} -> DNat {n} -> DNat {suc n}              = \n DN s z. s (n DN s z);
let dadd : {m n} -> DNat {m} -> DNat {n} -> DNat {add m n}
    = \{n=n} a b DN s z. a (\k. DN (add k n)) s (b DN s z);
--let dmul : {m n} -> DNat {m} -> DNat {n} -> DNat {mul m n}
--    = \{m}{n=n} a b DN s z. a (\k. DN (mul k n)) (b (\k. DN _) s) z;

let dfoldnat : {A : Nat -> U}{n} -> ({m} -> A m -> A (suc m)) -> A zero -> DNat {n} -> A n
    = \{A} reducer base dn. proj2 {Nat}{A} (dn (\n. Sigma Nat A {n})
        (\{m} s. dpair (suc m) (reducer {m} (proj2 s))) (dpair zero base));

let initWord : {n} -> DNat {n} -> LTree {n} Bit       = \dn. dn (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O);
-- initWord (ds (ds dz))


-- Finite Sets

let Fin : {n} -> U
    = \{n}. (F : Nat -> U) -> ({m} -> F m -> F (suc m)) -> ({m} -> F (suc m)) -> F n;
let fz : {n} -> Fin {suc n}                           = \F s z. z;
let fs : {n} -> Fin {n} -> Fin {suc n}                = \f F s z. s (f F s z);

let foldfin : {A : Nat -> U}{n} ->
              ({m} -> A m -> A (suc m)) -> ({m} -> A (suc m)) -> Fin {n} -> A n
    = \{A}{n} reducer base fn. proj2 {Nat}{A} (fn (\n. Sigma Nat A {n})
        (\{m} s. dpair (suc m) (reducer {m} (proj2 s))) (\{m}. dpair (suc m) base));
--foldfin {\_. Nat} suc zero (fz {suc zero})


-- Length-indexed Vectors

let Vec : {n} -> U -> U
    = \{n} A. (V : Nat -> U) -> V zero -> ({m} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A                         = \V n c. n;
let cons : {A n} -> A -> Vec {n} A -> Vec {suc n} A   = \a as V n c. c a (as V n c);
let head : {A n} -> Vec {suc n} A -> A                = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A        = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);
-- tail (cons I (cons O nil))

let foldvec : {A}{B : Nat -> U}{n} ->
              ({m} -> A -> B m -> B (suc m)) -> B zero -> Vec {n} A -> B n
    = \{A}{B}{n} reducer base v. proj2 {Nat}{B} (v (\n. Sigma Nat B {n}) (dpair zero base)
        (\{m} a s. dpair (suc m) (reducer {m} a (proj2 s))));
{-foldvec {Bit}{\n. Fin {suc n}}
    (\{m} b fn. b (Fin {suc (suc m)}) (fs fn) (fn (\n. Fin {suc n}) fs fz))
    fz (cons I (cons O nil))-}

let lookupVec : {A m} -> Fin {m} -> Vec {m} A -> A
    = \{A} fn v. (\k. v (\_. A) _ (\{n} a acc. (add (minus k n) (minus n k)) A (\_. acc) a))
        (fn (\_. Nat) suc zero);
let lookup : {A m} -> Nat -> Vec {m} A -> A
    = \{A} n v. v (\_. A) _ (\{m} a acc. (add (minus m n) (minus n m)) A (\_. acc) a);
--lookup {Bit} (fs fz) (cons I (cons O nil))

let updateVec : {A m} -> Fin {m} -> Vec {m} A -> A -> Vec {m} A
    = \{A} fn v newA. (\k. v (\n. Vec {n} A) nil (\{m} a as. cons ((diff m k) A (\_. newA) a) as))
        (fn (\_. Nat) suc zero);
let update : {A m} -> Nat -> Vec {m} A -> A -> Vec {m} A
    = \{A}{n} n v newA. v (\n. Vec {n} A) nil (\{m} a as. cons ((diff m n) A (\_. newA) a) as);
updateVec (suc zero) (cons I (cons I nil)) O

let cmpBitVec : {n} -> Vec {n} Bit -> Vec {n} Bit -> Bit
    = \{n} v1 v2. v1 (\_. Bit) I (\{m} a acc. and acc (xnor a (lookup {m=n} m v2)));


-- Height-indexed Binary Leaf-only Trees

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> LTree {zero} A                 = \a T l n. l a;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A = \ta tb T l n. n (ta T l n) (tb T l n);
let divine : {A} -> LTree {zero} A -> A               = \{A} t. t (\_. A) (\a. a) _;
let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);
-- divine (leaf O)
-- lbranch (node (leaf O) (leaf I))

let foldltree : {A}{B : Nat -> U}{n} ->
                ({m} -> B m -> B m -> B (suc m)) -> (A -> B zero) -> LTree {n} A -> B n
    =\{A}{B}{n} reducer base tr. proj2 {Nat}{B} (tr
        (\n. Sigma Nat B {n}) (\a. dpair zero (base a))
        (\{m} s1 s2. dpair (suc m) (reducer {m} (proj2 s1) (proj2 s2))));
--foldltree {Bit}{\_. Nat} add (\b. b Nat (suc zero) zero) (node (leaf I) (leaf I))

let lookupTree : {A n} -> Vec {n} Bit -> LTree {n} A -> A
    = \{A}{n} v tr. tr (\_. A) id (\{m} l r. (lookup {m=n} m v) _ r l);
--lookupTree {Bit} (cons I (cons O nil)) (node (node (leaf I) (leaf I)) (node (leaf O) (leaf I)))


-- Bush
-- Reference: Dependently Typed Folds for Nested Data Types, Peng Fu and Peter Selinger

let Bush : {n} -> U -> U
    = \{n} A. (B : Nat -> U) -> (A -> B zero) -> ({n} -> B (suc n)) ->
        ({n} -> B n -> B (suc (suc n)) -> B (suc n)) -> B n;
let bbase : {A} -> A -> Bush {zero} A                 = \a B b n c. b a;
let bnil : {n A} -> Bush {suc n} A                    = \B b n c. n;
let bcons : {n A} -> Bush {n} A -> Bush {suc (suc n)} A -> Bush {suc n} A
    = \x xs B b n c. c (x B b n c) (xs B b n c);
let mapbush : {A B n} -> (A -> B) -> Bush {n} A -> Bush {n} B
    = \{A}{B} fn bush. bush (\n. Bush {n} B) (\x. bbase (fn x)) bnil bcons;

-- [ O,
--   [ I, [ I ] ],
--   [ [ O ] ] ]
let somebush : Bush Bit
    = bcons (bbase O) (bcons
            (bcons (bbase I) (bcons
                   (bcons (bbase I) bnil)
                   bnil)) (bcons
            (bcons (bcons (bbase O) bnil)
                   bnil)
            bnil));
            
-- mapbush not somebush


-- Nullary Relations

let neg : U -> U                                      = \P. P -> Void;
let contradiction : {P Q} -> P -> neg P -> Q          = \p notp. absurd (notp p);

let Reflects : U -> Bit -> U                          = \P b. (R : Bit -> U) -> (P -> R I) -> (neg P -> R O) -> R b;
let ofyes : {P} -> P -> Reflects P I                  = \p R y n. y p;
let ofno : {P} -> neg P -> Reflects P O               = \negp R y n. n negp;

let Dec : (P : U) -> U
    = \P. {D} -> ((does : Bit) -> (proof : Reflects P does) -> D) -> D;
let because : {P} -> (does : Bit) -> Reflects P does -> Dec P
    = \does proof D. D does proof;
let yes : {P} -> P -> Dec P                           = \p. because I (ofyes p);
let no : {P} -> neg P -> Dec P                        = \negp. because O (ofno negp);

let Decidable : {A B} -> (A -> B -> U) -> U           = \{A}{B} Rel. (x : A)(y : B) -> Dec (Rel x y);


-- Unary Relations

let EmptySet : {A} -> A -> U                          = \_. Void;
let UniversalSet : {A} -> A -> U                      = \_. Unit;
let Member : {A} -> A -> (A -> U) -> U                = \x P. P x;
let Subset : {A} -> (A -> U) -> (A -> U) -> U         = \P Q. {x} -> Member x P -> Member x Q;
let Empty : {A} -> (A -> U) -> U                      = \P. {x} -> neg (Member x P);
let Universal : {A} -> (A -> U) -> U                  = \P. {x} -> Member x P;
let ImplPred : {A} -> (A -> U) -> (A -> U) -> A -> U  = \P Q x. Member x P -> Member x Q;
let Assert : {A B} -> (A -> B) -> (B -> U) -> A -> U  = \f P x. P (f x);


-- Binary Relations

let Implies : {A B} -> (A -> B -> U) -> (A -> B -> U) -> U
    = \P Q. {x y} -> P x y -> Q x y;
let Preserves : {A B} -> (A -> B) -> (A -> A -> U) -> (B -> B -> U) -> U
    = \f P Q. {x y} -> P x y -> Q (f x) (f y);

let Reflexive : {A} -> (A -> A -> U) -> U             = \Rel. {x} -> Rel x x;
let reflexive : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Reflexive Rel -> Reflexive (on Rel f)
    = \_ _ refl. refl;

let Symmetric : {A} -> (A -> A -> U) -> U             = \Rel. {x y} -> Rel x y -> Rel y x;
let symmetric : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Symmetric Rel -> Symmetric (on Rel f)
    = \_ _ sym. sym;

let Transitive : {A} -> (A -> A -> U) -> U            = \Rel. {i j k} -> Rel j k -> Rel i j -> Rel i k;
let transitive : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Transitive Rel -> Transitive (on Rel f)
    = \_ _ trans. trans;

let IsEquivalence : {A} -> (A -> A -> U) -> U
    = \{A} Rel. {R} -> ((refl : Reflexive {A} Rel) -> (sym : Symmetric {A} Rel) ->
        (trans : Transitive {A} Rel) -> R) -> R;
let isEquivalence : {A B}(f : B -> A)(Rel : A -> A -> U) -> IsEquivalence Rel -> IsEquivalence (on Rel f)
    = \f Rel eq E. eq (\refl sym trans. E
        (reflexive f Rel refl) (symmetric f Rel sym) (transitive f Rel trans));


let IsDecEquivalence : {A} -> (A -> A -> U) -> U
    = \{A} Rel. {R} -> ((DecRel : Decidable Rel) -> (isEquiv : IsEquivalence Rel) -> R) -> R;
let decidable : {A B}(f : B -> A)(Rel : A -> A -> U) -> Decidable Rel -> Decidable (on Rel f)
    = \f _ dec x y. dec (f x) (f y);
let isDecEquivalence : {A B}(f : B -> A)(Rel : A -> A -> U) ->
                       IsDecEquivalence Rel -> IsDecEquivalence (on Rel f)
    = \f Rel deq DE. deq (\DecRel isEquiv. DE (decidable f Rel DecRel) (isEquivalence f Rel isEquiv));

let Setoid : U
    = {S} -> ((T : U) -> (Rel : T -> T -> U) -> (isEquiv : IsEquivalence Rel) -> S) -> S;
let DecSetoid : U
    = {S} -> ((T : U) -> (Rel : T -> T -> U) -> (isDecEquiv : IsDecEquivalence Rel) -> S) -> S;


-- Monoid

let Monoid : U -> U                                   = \(M : U). ((neut : M) -> (comb : {A} -> A -> M -> M) -> M) -> M;

let maybeMonoid : {A} -> Monoid (Maybe A)             = \{Z} M. M nothing (\{Y} a _. just {Y} a);
-- maybeMonoid {Bit} (\neut comb. comb I neut)


-- Functors

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;

let maybeFunctor : Functor Maybe                      = \F. F (\fn ma M n j. ma M n (\a. j (fn a)));
-- maybeFunctor (\map. map not (just O))

let listFunctor : Functor List                        = \F. F (\fn la L n c. la L n (\a as. c (fn a) as));
-- listFunctor (\map. map not (cons O (cons I nil)))

let ltreeFunctor : Functor LTree                      = \F. F (\fn ta T l n. ta T (\a. l (fn a)) n);
-- ltreeFunctor (\map. map not (initWord (ds (ds dz))))


-- Applicatives

let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
        (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;

let maybeApp : App Maybe
    = \A. A just (\mf ma M n j. mf M n (\f. ma M n (\x. j (f x))));

let appFunctor : {F} -> App F -> Functor F
    = \app F. F (\{A}{B} fn fa. app (\pure ap. ap {A}{B} (pure fn) fa));
let listApp : App List
    = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (listFunctor (\map. map f xs)) bs));
-- listApp (\pure ap. ap (cons not (cons (\x. x) nil)) (cons O (cons I nil)))

let appComp : {F G : U -> U} -> App F -> App G -> App (\X. F (G X))
    = \{F}{G} appF appG A. A
        (\{X} fgx. appF {G X} (\pureF apF. pureF (appG {X} (\pureG apG. pureG fgx))))
        (\{X}{Y} fgf fgx. appF (\pureF apF. apF (apF {G (X -> Y)}{G X -> G Y}
            (pureF (\gf gx. appG (\pureG apG. apG gf gx))) fgf) fgx));
-- (appComp listApp listApp) (\pure ap. ap
--     (cons (cons not nil) (cons (cons (\x. x) nil) nil))
--     (cons (cons O (cons I nil)) (cons (cons I nil) nil)))


-- Monads

let Monad : (U -> U) -> U
    = \(F : U -> U). {T} -> ((return : {A} -> A -> F A) ->
        (bind : {A B} -> F A -> (A -> F B) -> F B) -> F T) -> F T;

let contMonad : {W} -> Monad (Cont W)
    = \F. F (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));

let monadApp : {F} -> Monad F -> App F
    = \monad A. A (\x. monad (\return bind. return x))
        (\fs xs. monad (\return bind. bind fs (\f. bind xs (\x. return (f x)))));

let mapM : {A B}{M : U -> U}{monad : Monad M} -> (A -> M B) -> List A -> M (List B)
    = (\{A}{B}{M}{monad} f as. monad
        (\return bind. as (M (List B)) (return nil)
            (\a r. bind {B}{List B} (f a) (\x. bind {List B}{List B} r (\xs. return (cons x xs))))));
-- run {List Bit} (mapM {monad=contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)


-- Traversables

let Trav : (F : U -> U) -> U
    = \F. {S : U -> U}{T} -> ((traverse : {G : U -> U}{app : App G}{B A} -> (A -> G B) -> F A -> G (F B)) -> S (F T)) -> S (F T);

let maybeTrav : Trav Maybe
    = \T. T (\{app=app} f ma. app (\pure ap. ma _ (pure nothing) (\a. ap (pure just) (f a))));
let listOfNonzero : Nat -> List Nat = \n. n (List Nat) (\s. cons n nil) nil;
--maybeTrav {List} (\traverse. traverse {app=listApp} listOfNonzero (just (suc zero)))

let listTrav : Trav List
    = \T. T (\{app=app} f la. app (\pure ap. la _ (pure nil) (\a as. ap (ap (pure cons) (f a)) as)));
let maybeNonzero : Nat -> Maybe Nat = \n. n (Maybe Nat) (\s. just n) nothing;
--listTrav {Maybe} (\traverse. traverse {app=maybeApp} maybeNonzero (cons (suc zero) nil))

let ltreeTrav : {n} -> Trav (LTree {n})
    = \T. T (\{F}{app}{B} f ta. app (\pure ap. ta (\n. F (LTree {n} B))
        (\a. ap (pure leaf) (f a)) (\{m} l r. ap (ap (pure node) l) r)));
let maybeO : Bit -> Maybe Unit = \b. b (Maybe Unit) nothing (just tt);
--ltreeTrav {S=Maybe} (\traverse. traverse {app=maybeApp} maybeO (initWord (ds dz)))


-- Dependent Sums

let Sigma : (A : U)(B : A -> U){a : A} -> U
    = \A B {a}. (S : A -> U) -> ((fst : A)(snd : B fst) -> S fst) -> S a;
let dpair : {A}{B : A -> U}(a : A)(b : B a) -> Sigma A B {a}
    = \a b S s. s a b;
let proj1 : {A}{B : A -> U}{a : A} -> Sigma A B {a} -> A
    = \{A} s. s (\_. A) (\fst snd. fst);
let proj2 : {A}{B : A -> U}{a : A} -> Sigma A B {a} -> B a
    = \{B=B} s. s B (\fst snd. snd);
let smap : {A B}{P : A -> U}{Q : B -> U}(f : A -> B) ->
           ({x} -> P x -> Q (f x)) -> Sigma A P -> Sigma B Q
    =\{B=B}{Q=Q} f g s. s (\b. Sigma B Q) (\x y. dpair (f x) (g y));



-- Containers

let Container : {Sh} -> U
    = \{Sh}. {C : U -> U} -> ((Shape : U)(Position : Shape -> U) -> C Shape) -> C Sh;
let cpair : (Sh : U)(Pos : Sh -> U) -> Container {Sh}
    = \Sh Pos C. C Sh Pos;
let cshape : {Sh} -> Container {Sh} -> U
    = \C. C (\Sh Pos. Sh);
let cposition : {Sh} -> Container {Sh} -> Sh -> U
    = \C. C {\Sh. Sh -> U} (\Sh Pos. Pos);
let cextend : {Sh} -> Container {Sh} -> U -> U
    = \{Sh} C X. Sigma Sh (\s. (cposition {Sh} C) s -> X);

let CMorphism : {Sh1 Sh2 cmS}(C1 C2 : Container) -> U
    = \{Sh1}{Sh2}{cmS} C1 C2. {M : (sh1 : U)(sh2 : U) -> Container {sh1} -> Container {sh2} -> (sh1 -> sh2) -> U} ->
        ({sh1 sh2 c1 c2}(shape : sh1 -> sh2)(position : {s} -> (cposition c2) (shape s) -> (cposition c1) s) ->
        M sh1 sh2 c1 c2 shape) -> M Sh1 Sh2 C1 C2 cmS;
let cmpair : {Sh1 Sh2 C1 C2}(cmS : Sh1 -> Sh2) -> ({s} -> (cposition C2) (cmS s) -> (cposition C1) s) -> CMorphism C1 C2
    = \{Sh1}{Sh2}{C1}{C2} cmS cmP CM. CM {Sh1}{Sh2}{C1}{C2} cmS cmP;
let cmshape : {Sh1 Sh2 C1 C2} -> CMorphism C1 C2 -> Sh1 -> Sh2
    = \CM. CM {\Sh1 Sh2 _ _ _. Sh1 -> Sh2} (\cmS cmP. cmS);
let cmposition : {cmS C1 C2} -> CMorphism C1 C2 -> {s} -> (cposition C2) (cmS s) -> (cposition C1) s
    = \CM. CM {\_ _ C1 C2 cmS. {s} -> (cposition C2) (cmS s) -> (cposition C1) s} (\cmS cmP. cmP);
--let cmExtend ...

let AllC : (C : Container){X}(P : X -> U)(cx : cextend C X) -> U
    = \C P cx. {A} -> ((proof : {p} -> P (proj2 cx p)) -> A) -> A;
let AnyC : (C : Container){X}(P : X -> U)(cx : cextend C X) -> U
    = \C P cx. {A} -> ((proof : Sigma _ (\p. P (proj2 cx p))) -> A) -> A;