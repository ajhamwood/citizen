---------------
-- Functions --
---------------

let id : {A} -> A -> A                                = \x. x;
let const : {A B} -> A -> B -> A                      = \x _. x;
let const2 : {A B} -> A -> B -> B                     = \_. id;
let apply : {A B} -> A -> (A -> B) -> B               = \x f. f x;

let dcomp
    : {A : U}{B : A -> U}{C : {x : A} -> B x -> U} ->
      ({x : A}(y : B x) -> C {x} y) -> (g : (x : A) -> B x) ->
      (x : A) -> C {x} (g x)
    = \f g x. f {x} (g x);
let comp : {A B C : U} -> (B -> C) -> (A -> B) -> A -> C = \f g x. f (g x);

let dcomp2
    : {A1 : U}{A2 : A1 -> U}{B : (x : A1) -> A2 x -> U}
      {C : {x : A1}{y : A2 x} -> B x y -> U} ->
      ({x : A1}{y : A2 x} -> (z : B x y) -> C {x}{y} z) ->
      (g : (x : A1) -> (y : A2 x) -> B x y) ->
      (x : A1) -> (y : A2 x) -> C {x}{y} (g x y)
    = \f g x y. f {x}{y} (g x y);
let comp2 : {A1 A2 B C : U} -> (B -> C) -> (A1 -> A2 -> B) -> A1 -> A2 -> C
    = \f g x y. f (g x y);

let flip : {A B}{C : A -> B -> U} -> ((x : A)(y : B) -> C x y) -> (y : B) -> (x : A) -> C x y
    = \f y x. f x y;
let pipe : {A : U}{B : A -> U} -> (a : A) -> ((a : A) -> B a) -> B a
    = \x f. f x;

let bincomp : {A B C D E : U} -> (A -> B -> C) -> (C -> D -> E) -> (A -> B -> D) -> (A -> B -> E)
    = \f star g x y. star (f x y) (g x y);

let leftbin : {A B C D : U} -> (A -> B -> C) -> (C -> B -> D) -> A -> B -> D
    = \{A}{B}{C}{D} f star. bincomp {A}{B}{C}{B}{D} f star (const2 {A}{B});
let rightbin : {A B C D : U} -> (A -> C -> D) -> (A -> B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star g. bincomp {A}{B}{A}{C}{D} (const {A}{B}) star g;

let leftun : {A B C D : U} -> (A -> C) -> (C -> B -> D) -> A -> B -> D
    = \{A}{B}{C}{D} f star. leftbin {A}{B}{C}{D} (dcomp2 {A}{\_. B}{\_ _.A}{\_. C} f (const {A}{B})) star;
let rightun : {A B C D : U} -> (A -> C -> D) -> (B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star g. rightbin {A}{B}{C}{D} star (dcomp2 {A}{\_. B}{\_ _. B}{\_. C} g (const2 {A}{B}));
let twoun : {A B C D E : U} -> (A -> C) -> (C -> D -> E) -> (B -> D) -> A -> B -> E
    = \{A}{B}{C}{D}{E} f star g. bincomp {A}{B}{C}{D}{E} (leftun {A}{B}{C}{C} f (const {C}{B})) star
      (rightun {A}{B}{D}{D} (const2 {A}{D}) g);

let on2 : {A B C D : U} -> (C -> C -> D) -> (A -> B -> C) -> A -> B -> D
    = \{A}{B}{C}{D} star f. bincomp f star f;
let on : {A B C : U} -> (B -> B -> C) -> (A -> B) -> A -> A -> C
    = \{A}{B}{C} star f. twoun f star f;


let on : {A B C : U} -> (B -> B -> C) -> (A -> B) -> A -> A -> C
    = \{A}{B}{C} star f x y. star (f x) (f y);


let typeof : {A} -> A -> U                            = \{A} a. A;



-----------------------------
-- Non-dependent Datatypes --
-----------------------------

-- Void

let Void : U                                          = Bot;
let absurd : {A} -> Void -> A                         = exfalso;
let absurdD : {A : Void -> U}(v : Void) -> A v        = \{A} v. exfalso {A v} v;

let absurdIsUnique : {C}(h : Void -> C)(w : Bot) -> Eq {C} (exfalso w) (h w)
    = \{C} h. exfalso;

-- tt (Eq {Nat} zero zero -> Bot) (\zisz. zisz (\_. Bot) _)

--let Void : U                                        = (V : U) -> V;
--let absurd : {A} -> Void -> A                       = \V. _;

-- Unit

let Unit : U                                          = (T : U) -> T -> T;
let tt : Unit                                         = \T t. t;


-- Booleans

let Bit : U                                           = (B : U) -> B -> B -> B;
let I : Bit                                           = \B i o. i;
let O : Bit                                           = \B i o. o;
let not : Bit -> Bit                                  = \b B i o. b B o i;
let and : Bit -> Bit -> Bit                           = \x y B i o. x B (y B i o) (x B i o);
let or : Bit -> Bit -> Bit                            = \x y B i o. x B (x B i o) (y B i o);
let xor : Bit -> Bit -> Bit                           = \x y B i o. x B (y B o i) (y B i o);
let nand : Bit -> Bit -> Bit                          = \x y B i o. x B (y B o i) (x B o i);
let nor : Bit -> Bit -> Bit                           = \x y B i o. x B (x B o i) (y B o i);
let xnor : Bit -> Bit -> Bit                          = \x y B i o. x B (y B i o) (y B o i);
let if : {R} -> Bit -> R -> R -> R                    = \p a b. p _ a b;
let carry : Bit -> Bit -> Bit -> Bit                  = \a b c. or (and a b) (and c (xor a b));
let sum : Bit -> Bit -> Bit -> Bit                    = \a b c. xor (xor a b) c;


-- Nats

let Nat : U                                           = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                                        = \N s z. z;
let suc : Nat -> Nat                                  = \n N s z. s (n N s z);
let add : Nat -> Nat -> Nat                           = \a b N s z. a N s (b N s z);
let mul : Nat -> Nat -> Nat                           = \a b N s z. a N (b N s) z;
let pred : Nat -> Nat
    = \n. snd {Nat} (n _ (\p. pair (suc (fst p)) (fst p)) (pair zero zero));
let pred : Nat -> Nat
    = \n N s z. n ((N -> N) -> N) (\c k. k (c s)) (\_. z) (\x. x);
let minus : Nat -> Nat -> Nat                         = \m n. n _ pred m;
let eqz : Nat -> Bit                                  = \n. n _ (\_. O) I;
let diff : Nat -> Nat -> Nat                          = \m n. add (minus m n) (minus n m);
let eqn : Nat -> Nat -> Bit                           = \m n. (diff m n) Bit (\_. O) I;

let foldnat : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A)
        (\p. pair (suc (fst p)) (reducer (fst p) (snd p))) (pair zero base));
--let pred : Nat -> Nat = foldnat const zero;
let fact : Nat -> Nat = \n. foldnat {Nat} (\n. mul (suc n)) (suc zero) n;
-- fact (suc (suc (suc zero)))


-- Difference Nats

let DiffNat : U                                       = Nat -> Nat;
let zeroD : DiffNat                                   = id;
let sucD : DiffNat -> DiffNat                         = comp suc;
let addD : DiffNat -> DiffNat -> DiffNat              = comp;
let fromDiffNat : DiffNat -> Nat                      = apply zero;
let toDiffNat : Nat -> DiffNat                        = add;


-- Identity

let Wrap : U -> U                                     = \A. (W : U) -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A                         = \a W w. w a;
let unwrap : {A} -> Wrap A -> A                       = \{A} w. w A (\x. x);


-- Products

let Pair : U -> U -> U                                = \A B. (P : U) -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B                = \a b P p. p a b;
let fst : {A B} -> Pair A B -> A                      = \{A} s. s A (\a b. a);
let snd : {A B} -> Pair A B -> B                      = \{B=B} s. s B (\a b. b);


-- Maybe

let Maybe : U -> U                                    = \A. (M : U) -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A                          = \M n j. n;
let just : {A} -> A -> Maybe A                        = \a M n j. j a;
let maybe : {B A} -> B -> (A -> B) -> Maybe A -> B    = \{B} b f ma. ma B b f;


-- Either

let Either : U -> U -> U                              = \A B. (E : U) -> (A -> E) -> (B -> E) -> E;
let left : {A B} -> A -> Either A B                   = \a E l r. l a;
let right : {A B} -> B -> Either A B                  = \b E l r. r b;
let either : {C A B} -> (A -> C) -> (B -> C) -> Either A B -> C = \{C} f g eab. eab C f g;


-- These

let These : U -> U -> U
    = \A B. (T : U) -> (A -> T) -> (B -> T) -> (A -> B -> T) -> T;
let this : {A B} -> A -> These A B                    = \a T l r lr. l a;
let that : {A B} -> B -> These A B                    = \b T l r lr. r b;
let both : {A B} -> A -> B -> These A B               = \a b T l r lr. lr a b;
let these : {T A B} -> (A -> T) -> (B -> T) -> (A -> B -> T) -> These A B -> T
    = \{T} l r lr t. t T l r lr;


-- Lists

let List : U -> U                                     = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                              = \L n c. n;
let cons : {A} -> A -> List A -> List A               = \a as L n c. c a (as L n c);
let concat : {A} -> List A -> List A -> List A        = \{A} la lb. la (List A) lb cons;
let length : {A} -> List A -> Nat                     = \l. l Nat zero (\_. suc);

let foldlist : {A B} -> (List A -> A -> B -> B) -> B -> List A -> B
    = \{A}{B} reducer base l. snd {List A} (l (Pair (List A) B) (pair nil base)
        (\a p. pair (cons a (fst p)) (reducer (fst p) a (snd p))));

let listHead : {A} -> List A -> Maybe A = \{A} l. l (Maybe A) nothing (\a as. just a);
let listTail : {A} -> List A -> Maybe (List A)
    = \{A} l. snd (l (Pair (List A) (Maybe (List A))) (pair nil nothing)
        (\a p. pair (cons a (fst p)) (just (fst p))));
--let listTail = \{A}. foldlist {A}{List A} (\l _ _. l) nil;
let splitListAtHead : {A} -> List A -> Maybe (Pair A (List A))
    = \{A} l. snd (l (Pair (List A) (Maybe (Pair A (List A)))) (pair nil nothing)
        (\a p. pair (cons a (fst p)) (just (pair a (fst p)))));
let listLookup : {A}(l : List A) -> Fin {length l} -> A
    = \{A} l fn. (fn (\_. List A) (\acc. (listTail acc) (List A) _ id) l) A _ (\a as. a);

let listUpdate : {A} -> Nat -> List A -> A -> List A
    = \{A} n l newA. foldlist {A}{List A} (\l a acc. cons ((diff n (length l)) A (\_. a) newA) acc) nil l;

let reverse : {A} -> List A -> List A                 = \l. l _ id (\a acc as. acc (cons a as)) nil;


-- Non-empty list

let Nonempty : U -> U                                 = \A. (N : U) -> (A -> N) -> (A -> N -> N) -> N;
let sing : {A} -> A -> Nonempty A                     = \a N s c. s a;
let ncons : {A} -> A -> Nonempty A -> Nonempty A      = \a as N s c. c a (as N s c);

let nonemptyToList : {A} -> Nonempty A -> List A      = \{A} n. n (List A) (\a. cons a nil) cons;
let splitNonemptyAtHead : {A} -> Nonempty A -> Pair A (List A)
    = \{A} n. n (Pair A (List A)) (\a. pair a nil) (\a p. pair a (p _ cons));


-- Binary Trees

let BTree : U -> U                                    = \A. (B : U) -> (A -> B -> B -> B) -> (A -> B) -> B;
let bleaf : {A} -> A -> BTree A                       = \a B n l. l a;
let bnode : {A} -> A -> BTree A -> BTree A -> BTree A = \a ta tb B n l. n a (ta B n l) (tb B n l);


-- Rose Trees

let RTree : U -> U                                    = \A. (R : U) -> (A -> R) -> R -> (R -> R -> R) -> R;
let rleaf : {A} -> A -> RTree A                       = \a R l n c. l a;
let rnil : {A} -> RTree A                             = \R l n c. n;
let rcons : {A} -> RTree A -> List (RTree A) -> RTree A = \r rs R l n c. c (r R l n c) (rs R n (\a. c (a R l n c)));
-- rcons (rcons rnil (cons (rcons (rleaf I) nil) nil)) (cons (rleaf O) nil)

let spread : {A} -> RTree A -> List (RTree A)
    = \{A} r. snd (r (Pair (RTree A) (List (RTree A)))
        (\a. pair (rleaf a) (cons (rleaf a) nil)) (pair rnil nil)
        (\p1 p2. pair (rcons (fst p1) (snd p2)) (cons (fst p1) (snd p2))));

let RTree : U -> U                                    = \A. (R : U) -> (A -> R) -> (R -> R) -> (R -> R -> R) -> R;
let rleaf : {A} -> A -> RTree A                       = \a R l s c. l a;
let rsing : {A} -> RTree A -> RTree A                 = \r R l s c. s (r R l s c);
let rcons : {A} -> RTree A -> Nonempty (RTree A) -> RTree A
    = \r rs R l s c. c (r R l s c) (rs R (\a. a R l s c) (\a. c (a R l s c)));

let spread : {A} -> RTree A -> Nonempty (RTree A) = \{A} r. (snd (r
    (Pair (RTree A) (Either (RTree A) (Nonempty (RTree A))))
    (\a. pair (rleaf a) (left (rleaf a)))
    (\p. pair (rsing (fst p)) (right (sing ((snd p) (RTree A) rsing (const (fst p))))))
    (\p1 p2. pair
        (rcons (fst p1) ((snd p2) (Nonempty (RTree A)) sing id))
        (right (ncons (fst p1) ((snd p2) (Nonempty (RTree A)) sing id))))))
    (Nonempty (RTree A)) sing id;
let bunch : {A} -> Nonempty (RTree A) -> RTree A
    = \{A} n. snd (n (Pair (Nonempty (RTree A)) (RTree A))
        (\r. pair (sing r) r) (\r p. pair (ncons r (fst p)) (rcons r (fst p))));


-- Continuations

let Cont : U -> U -> U                                = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A       = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W          = \{W} c f. c W (\k. k f);
let reset : {W} -> Cont W W -> W                      = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));



-------------------------
-- Dependent Datatypes --
-------------------------

-- Dependent Identity

let DWrap : {T} -> T -> U                             = \{T} t. (W : T -> U) -> ((x : T) -> W x) -> W t;
let dwrap : {T} -> (t : T) -> DWrap {T} t             = \{V} v W w. w v;
let undwrap : {T t} -> DWrap {T} t -> T               = \{V}{v} w. w (\_. V) (\_. v);
-- tt (DWrap tt) ((\t. tt (DWrap {Unit} t) (dwrap t)) tt)


-- Finite Sets

let Fin : {n} -> U
    = \{n}. (F : Nat -> U) -> ({m} -> F m -> F (suc m)) -> ({m} -> F (suc m)) -> F n;
let fz : {n} -> Fin {suc n}                           = \F s z. z;
let fs : {n} -> Fin {n} -> Fin {suc n}                = \f F s z. s (f F s z);

let foldfin
    : {A : Nat -> U}{n} -> ({m} -> A m -> A (suc m)) -> ({m} -> A (suc m)) -> Fin {n} -> A n
    = \{A}{n} reducer base fn. proj2 {Nat}{A} (fn (\n. Sigma Nat A {n})
        (\{m} s. dpair (suc m) (reducer {m} (proj2 s))) (\{m}. dpair (suc m) base));
--foldfin {\_. Nat} suc zero (fz {suc zero})


-- Length-indexed Vectors

let Vec : {n} -> U -> U
    = \{n} A. (V : Nat -> U) -> V zero -> ({m} -> A -> V m -> V (suc m)) -> V n;
let vnil : {A} -> Vec {zero} A                        = \V n c. n;
let vcons : {A n} -> A -> Vec {n} A -> Vec {suc n} A  = \a as V n c. c a (as V n c);
let head : {A n} -> Vec {suc n} A -> A                = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A        = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);
-- tail (vcons I (vcons O vnil))
let vconcat : {A m n} -> Vec {m} A -> Vec {n} A -> Vec {add m n} A
    = \{A}{n=n} v1 v2. v1 (\m. Vec {add m n} A) v2 vcons;

let foldvec
    : {A : Nat -> U}{B n} -> ({m} -> B -> Vec {m} B -> A m -> A (suc m)) -> A zero -> Vec {n} B -> A n
    = \{A}{B}{n} reducer base v. snd (proj2 (v
        (\n. Sigma Nat (\n. Pair (Vec {n} B) (A n)) {n})
        (dpair zero (pair vnil base))
        (\{m} b s. s (\m. Sigma Nat (\n. Pair (Vec {n} B) (A n)) {suc m}) (\dfst dsnd. dpair
          (suc dfst) (pair (vcons b (fst dsnd)) (reducer b (fst dsnd) (snd dsnd)))))));
{-foldvec {Bit}{\n. Fin {suc n}}
    (\{m} _ b fn. b (Fin {suc (suc m)}) (fs fn) (fn (\n. Fin {suc n}) fs fz))
    fz (vcons I (vcons O vnil))-}

let lookupVec : {A m} -> Fin {m} -> Vec {m} A -> A
    = \{A} fn v. (\k. v (\_. A) _ (\{n} a acc. (diff n k) A (\_. acc) a))
        (fn (\_. Nat) suc zero);
let lookup : {A m} -> Nat -> Vec {m} A -> A
    = \{A} n v. v (\_. A) _ (\{m} a acc. (diff n m) A (\_. acc) a);
--lookup {Bit} (fs fz) (vcons I (vcons O vnil))

let updateVec : {A m} -> Fin {m} -> Vec {m} A -> A -> Vec {m} A
    = \{A} fn v newA. (\k. v (\n. Vec {n} A) vnil (\{m} a as. vcons ((diff m k) A (\_. newA) a) as))
        (fn (\_. Nat) suc zero);
let update : {A m} -> Nat -> Vec {m} A -> A -> Vec {m} A
    = \{A}{n} n v newA. v (\n. Vec {n} A) vnil (\{m} a as. vcons ((diff m n) A (\_. newA) a) as);
updateVec (suc zero) (vcons I (vcons I vnil)) O

let cmpBitVec : {n} -> Vec {n} Bit -> Vec {n} Bit -> Bit
    = \{n} v1 v2. v1 (\_. Bit) I (\{m} a acc. and acc (xnor a (lookup {m=n} m v2)));


-- Tuples

let Tuple : List U -> U
    = \L. (T : List U -> U) -> T nil -> ({A As} -> A -> T As -> T (cons A As)) -> T L;
let tnil : Tuple nil = \T n c. n;
let tcons : {A As} -> A -> Tuple As -> Tuple (cons A As) = \a tas T n c. c a (tas T n c);
--tcons {Nat}{cons Bit nil} zero (tcons I tnil)


-- Height-indexed Binary Leaf-only Trees

let LTree : {n} -> U -> U
    = \{n} A. (T : Nat -> U) -> (A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> LTree {zero} A                 = \a T l n. l a;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A = \ta tb T l n. n (ta T l n) (tb T l n);
let divine : {A} -> LTree {zero} A -> A               = \{A} t. t (\_. A) (\a. a) _;
let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);
-- divine (leaf O)
-- lbranch (node (leaf O) (leaf I))

let foldltree
    : {A}{B : Nat -> U}{n} -> ({m} -> B m -> B m -> B (suc m)) -> (A -> B zero) -> LTree {n} A -> B n
    =\{A}{B}{n} reducer base tr. proj2 {Nat}{B} (tr
        (\n. Sigma Nat B {n}) (\a. dpair zero (base a))
        (\{m} s1 s2. dpair (suc m) (reducer {m} (proj2 s1) (proj2 s2))));
--foldltree {Bit}{\_. Nat} add (\b. b Nat (suc zero) zero) (node (leaf I) (leaf I))

let lookupTree : {A n} -> Vec {n} Bit -> LTree {n} A -> A
    = \{A}{n} v tr. tr (\_. A) id (\{m} l r. (lookup {m=n} m v) _ r l);
--lookupTree {Bit} (vcons I (vcons O vnil)) (node (node (leaf I) (leaf I)) (node (leaf O) (leaf I)))


-- Bush
-- Reference: Dependently Typed Folds for Nested Data Types, Peng Fu and Peter Selinger

let Bush : {n} -> U -> U
    = \{n} A. (B : Nat -> U) -> (A -> B zero) -> ({n} -> B (suc n)) ->
        ({n} -> B n -> B (suc (suc n)) -> B (suc n)) -> B n;
let bbase : {A} -> A -> Bush {zero} A                 = \a B b n c. b a;
let bnil : {n A} -> Bush {suc n} A                    = \B b n c. n;
let bcons : {n A} -> Bush {n} A -> Bush {suc (suc n)} A -> Bush {suc n} A
    = \x xs B b n c. c (x B b n c) (xs B b n c);
let mapbush : {A B n} -> (A -> B) -> Bush {n} A -> Bush {n} B
    = \{A}{B} fn bush. bush (\n. Bush {n} B) (\x. bbase (fn x)) bnil bcons;

-- [ O,
--   [ I, [ I ] ],
--   [ [ O ] ] ]
let somebush : Bush Bit
    = bcons (bbase O) (bcons
            (bcons (bbase I) (bcons
                   (bcons (bbase I) bnil)
                   bnil)) (bcons
            (bcons (bcons (bbase O) bnil)
                   bnil)
            bnil));
            
-- mapbush not somebush



-------------------------
-- Induction Datatypes --
-------------------------

-- Void Induction

let VoidInd : {v} -> U                                = \{v}. (VI : Void -> U) -> VI v;
let voidind : {v} -> VoidInd {v}                      = \{v} _. exfalso v;

-- Unit Induction

let UnitInd : {u} -> U                                = \{u}. (UI : Unit -> U) -> UI tt -> UI u;
let ttind : UnitInd {tt}                              = \UI t. t;

-- Bool and Bool Induction

let Bool : U                                          = (B : U) -> B -> B -> B;
let true : Bool                                       = \B t f. t;
let false : Bool                                      = \B t f. f;

let BoolInd : {b} -> U                                = \{b}. (BI : Bool -> U) -> BI true -> BI false -> BI b;
let trueind : BoolInd {true}                          = \BI t f. t;
let falseind : BoolInd {false}                        = \BI t f. f;

-- Pair Induction

let PairInd : (A B : U){p} -> U
    = \A B {p}. (PI : Pair A B -> U) -> ((a : A)(b : B) -> PI (pair a b)) -> PI p;
let pairind : {A B}(a : A)(b : B) -> PairInd A B {pair a b}
    = \a b PI p. p a b;

-- Nat Induction

let NatInd : {n} -> U
    = \{n}. (NI : Nat -> U) -> ({m} -> NI m -> NI (suc m)) -> NI zero -> NI n;
let zi : NatInd {zero}                                = \NI s z. z;
let si : {n} -> NatInd {n} -> NatInd {suc n}          = \n NI s z. s (n NI s z);
let addind : {m n} -> NatInd {m} -> NatInd {n} -> NatInd {add m n}
    = \{n=n} a b NI s z. a (\k. NI (add k n)) s (b NI s z);
--let mulind : {m n} -> NatInd {m} -> NatInd {n} -> NatInd {mul m n}
--    = \{m}{n=n} a b NI s z. a (\k. NI (mul k n)) (b (\k. NI _) s) z;
let lowerNatInd : {n} -> NatInd {n} -> Nat            = \{n} _. n;

let foldnatind
    : {A : Nat -> U}{n} -> ({m} -> NatInd {m} -> A m -> A (suc m)) -> A zero -> NatInd {n} -> A n
    = \{A}{n} reducer base ni. snd (proj2 (ni
        (\n. Sigma Nat (\n. Pair (NatInd {n}) (A n)) {n})
        (\{m} s. s (\m. Sigma Nat (\n. Pair (NatInd {n}) (A n)) {suc m}) (\dfst dsnd. dpair
          (suc dfst) (pair (si (fst dsnd)) (reducer (fst dsnd) (snd dsnd)))))
        (dpair zero (pair zi base))));
--foldnatind {\m. Vec {m} Bit} (\{m} ni v. vcons I v) vnil (si zi)
let dfoldnat
    : {S : U -> U}{Z : U}{n} -> ({A m} -> NatInd {m} -> A -> S A) -> Z -> NatInd {n} -> n U S Z
    = \{S}{Z}{n} reducer base ni. snd (proj2 (ni
        (\n. Sigma Nat (\n. Pair (NatInd {n}) (n U S Z)) {n})
        (\{m} s. s (\m. Sigma Nat (\n. Pair (NatInd {n}) (n U S Z)) {suc m}) (\dfst dsnd. dpair
          (suc dfst) (pair (si (fst dsnd)) (reducer (fst dsnd) (snd dsnd)))))
        (dpair zero (pair zi base))));
--dfoldnat {\_. Vec {zero} Bit}{Vec {zero} Bit}{suc (suc zero)} (\ni a. vnil) vnil (si (si zi))

let initWord : {n} -> NatInd {n} -> LTree {n} Bit     = \ni. ni (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O);
-- initWord (si (si zi))

-- Maybe Induction

let MaybeInd : (A : U){ma} -> U
    = \A {ma}. (MI : Maybe A -> U) -> MI nothing -> ((a : A) -> MI (just a)) -> MI ma;
let nothingind : {A} -> MaybeInd A {nothing}          = \MI n j. n;
let justind : {A}(a : A) -> MaybeInd A {just a}       = \a MI n j. j a;
let lowerMaybeInd : {A ma} -> MaybeInd A {ma} -> Maybe A
    = \{ma=ma} _. ma;

let maybeind
    : {A}{B : Maybe A -> U} -> B nothing -> ((a : A) -> B (just a)) ->
      {ma : Maybe A} -> MaybeInd A {ma} -> B ma
    = \{B=B} b f mi. mi B b f;
--maybeind {Nat}{\mn. mn U Unit (\n. Fin {suc n})} tt (\v. fz {v}) (djust (suc zero))
--proj2 {Maybe Nat}{\mn. mn U Unit (\n. Fin {suc n})} (dpair (just (suc zero)) fz)

-- Either Induction

let EitherInd : (A B : U){e} -> U
    = \A B {e}. (EI : Either A B -> U) ->
         ((a : A) -> EI (left a)) -> ((b : B) -> EI (right b)) -> EI e;
let leftind : {A B}(a : A) -> EitherInd A B {left a}  = \a EI l r. l a;
let leftind : {A B}(b : B) -> EitherInd A B {right b} = \b EI l r. r b;

-- List Induction

let ListInd : (A : U){l : List A} -> U
    = \A {l}. (LI : List A -> U) -> LI nil -> ({as}(a : A) -> LI as -> LI (cons a as)) -> LI l;
let nilind : {A} -> ListInd A {nil}                   = \LI n c. n;
let consind : {A as}(a : A) -> ListInd A {as} -> ListInd A {cons a as}
    = \a as LI n c. c a (as LI n c);
let lowerListInd : {A as} -> ListInd A {as} -> List A = \{as=as} _. as;

-- Cont Induction

let ContInd : (W A : U){c} -> U
    = \W A {c}. (CI : Cont W A -> U) -> ((f : (A -> W) -> W) -> CI (cont f)) -> CI c;
let runind : {W A}(f : (A -> W) -> W) -> ContInd W A {cont f}
    = \f C c. c f;



---------------------------
-- Non-dependent Records --
---------------------------

-- Monoid Structure

let RawMonoid : U -> U
    = \C. (M : U) -> ((comb : C -> C -> C)(neut : C) -> M) -> M;

let treeMonoid : {T} -> RawMonoid (Tree T)            = \{T} _ M. M node tnil;
--treeMonoid (Tree Bit) (\comb neut. comb (comb neut (comb neut neut)) neut)
let listMonoid : {T} -> RawMonoid (List T)            = \{T} _ M. M concat nil;
--listMonoid (List Bit) (\comb neut. comb (cons I nil) neut)

-- Dependent...
let RawIndexedMonoid : {I}{monoid : RawMonoid I}(C : I -> U) -> U
    = \{I}{monoid} C. monoid U (\comb neut. {x}(M : I -> U) ->
        ((icomb : {i j} -> C i -> C j -> C (comb i j))(ineut :  C neut) -> M x) -> M x);
let natMonoid : RawMonoid Nat = \_ M. M add zero;
let vecMonoid : {T} -> RawIndexedMonoid {monoid=natMonoid} (\n. Vec {n} T)
    = \{T} _ M. M vconcat vnil;
--vecMonoid (\n. Vec {n} Bit) (\comb neut. comb (vcons I neut) neut)


-- Foldable

let Foldable : (U -> U) -> U
    = \F. (T : U) -> ((foldMap : {M A}{monoid : Monoid M} -> (A -> M) -> F A -> M) -> T) -> T;

let foldableTree : Foldable Tree
    = \T F. F (\{M}{monoid=monoid} f tr. monoid M (\comb neut. tr M comb f neut));
let bitToNat : Bit -> Nat = \b. b Nat (suc zero) zero;
--foldableTree Nat (\foldMap. foldMap {monoid=natMonoid} bitToNat
--    (node (leaf I) (node tnil (leaf I))))


-- Functors

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let map : {G : U -> U}{fun : Functor G}{A B} -> (A -> B) -> G A -> G B
    = \{fun=fun} f ga. fun (\map. map f ga);
--map {Maybe}{maybeFunctor} not (just O)

let maybeFunctor : Functor Maybe                      = \F. F (\f ma M n j. ma M n (\a. j (f a)));
-- maybeFunctor (\map. map not (just O))

let listFunctor : Functor List                        = \F. F (\f la L n c. la L n (\a as. c (f a) as));
-- listFunctor (\map. map not (cons O (cons I nil)))

let contFunctor : {W} -> Functor (Cont W)             = \F. F (\f ca C c. ca C (\k. c (\g. k (\x. g (f x)))));
-- run (contFunctor (\map. map not (cont (\k. k O)))) id

let ltreeFunctor : Functor LTree                      = \F. F (\f ta T l n. ta T (\a. l (f a)) n);
-- ltreeFunctor (\map. map not (initWord (si (si zi))))


-- Applicatives

let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
        (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;
let pure : {G : U -> U}{app : App G}{A} -> A -> G A
    = \{app=app} a. app (\pure ap. pure a);
let ap : {G : U -> U}{app : App G}{A B} -> G (A -> B) -> G A -> G B
    = \{app=app} gf ga. app (\pure ap. ap gf ga);
--ap {Maybe}{maybeApp} (pure {Maybe}{maybeApp} not) (pure {Maybe}{maybeApp} O)

let maybeApp : App Maybe
    = \A. A just (\mf ma M n j. mf M n (\f. ma M n (\x. j (f x))));
let contApp : {W} -> App (Cont W)
    = \A. A (\x. cont (\k. k x)) (\cf ca. cont (\k. run ca (\v. run cf (\f. k (f v)))));
--run (contApp (\pure ap. ap (pure not) (pure O))) id

let appFunctor : {F} -> App F -> Functor F
    = \app F. app (\pure ap. F (\{A}{B} f fa. ap {A}{B} (pure f) fa));
let listApp : App List
    = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (xs _ nil (\a as. cons (f a) as)) bs));
let listApp : App List
    = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (listFunctor (\map. map f xs)) bs));
-- listApp (\pure ap. ap (cons not (pure id)) (cons O (pure I)))

let appComp : {F G : U -> U} -> App F -> App G -> App (\X. F (G X))
    = \{F}{G} appF appG A. A
        (\{X} fgx. appF {G X} (\pureF apF. pureF (appG {X} (\pureG apG. pureG fgx))))
        (\{X}{Y} fgf fgx. appF (\pureF apF. apF (apF {G (X -> Y)}{G X -> G Y}
          (pureF (\gf gx. appG (\pureG apG. apG gf gx))) fgf) fgx));
-- (appComp listApp listApp) (\pure ap. ap
--     (cons (cons not nil) (cons (cons (\x. x) nil) nil))
--     (cons (cons O (cons I nil)) (cons (cons I nil) nil)))


-- Monads

let Monad : (U -> U) -> U
    = \(F : U -> U). {T} -> ((return : {A} -> A -> F A) ->
        (bind : {A B} -> F A -> (A -> F B) -> F B) -> F T) -> F T;
let return : {G : U -> U}{mon : Monad G}{A} -> A -> G A
    = \{mon=mon} a. mon (\ret bind. ret a);
let bind : {G : U -> U}{mon : Monad G}{A B} -> G A -> (A -> G B) -> G B
    = \{mon=mon} ga mf. mon (\ret bind. bind ga mf);
--bind {Maybe}{maybeMonad} (return {Maybe}{maybeMonad} O) just

let maybeMonad : Monad Maybe                          = \M. M just (\m f. m _ nothing f);
let listMonad : Monad List
    = \M. M (\x. cons x nil) (\m f. m _ nil (\x xs. concat (f x) xs));
--listMonad (\return bind. bind (cons zero (return (suc zero))) (\n. cons n (return (suc n))))
let contMonad : {W} -> Monad (Cont W)
    = \F. F (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));
--run {Nat} (contMonad (\return bind. bind (return zero) (\x. cont (\k. k (k x))))) suc

let monadApp : {F} -> Monad F -> App F
    = \monad A. monad (\return bind. A return (\fs xs. bind fs (\f. bind xs (\x. return (f x)))));

let mapM : {A B}{M : U -> U}{monad : Monad M} -> (A -> M B) -> List A -> M (List B)
    = (\{A}{B}{M}{monad} f as. monad
        (\return bind. as (M (List B)) (return nil)
          (\a r. bind {B}{List B} (f a) (\x. bind {List B}{List B} r (\xs. return (cons x xs))))));
-- run {List Bit} (mapM {monad=contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)


-- Traversables

let Trav : (U -> U) -> U
    = \F. {S : U -> U}{T} -> ((traverse : {G : U -> U}{app : App G}{B A} ->
        (A -> G B) -> F A -> G (F B)) -> S (F T)) -> S (F T);
let maybeTrav : Trav Maybe
    = \T. T (\{G}{app}{B} f ma. app {Maybe B} (\pure ap. ma (G (Maybe B))
        (pure nothing) (\a. ap (pure just) (f a))));
let listOfNonzero : Nat -> List Nat = \n. n (List Nat) (\s. cons n nil) nil;
--maybeTrav {List} (\traverse. traverse {app=listApp} listOfNonzero (just (suc zero)))

let listTrav : Trav List
    = \T. T (\{G}{app}{B} f la. app {List B} (\pure ap. la (G (List B))
        (pure nil) (\a as. ap (ap (pure cons) (f a)) as)));
let maybeNonzero : Nat -> Maybe Nat = \n. n (Maybe Nat) (\_. just n) nothing;
--listTrav {Maybe} (\traverse. traverse {app=maybeApp} maybeNonzero (cons (suc zero) nil))

let vecTrav : {n} -> Trav (Vec {n})
    = \{n} T. T (\{G}{app}{B} f va. app {Vec {n} B} (\pure ap. va (\n. G (Vec {n} B))
        (pure vnil) (\{m} a as. ap (ap (pure vcons) (f a)) as)));
--vecTrav {Maybe} (\traverse. traverse {app=maybeApp} maybeNonzero (vcons (suc zero) vnil))

let ltreeTrav : {n} -> Trav (LTree {n})
    = \T. T (\{F}{app}{B} f ta. app (\pure ap. ta (\n. F (LTree {n} B))
        (\a. ap (pure leaf) (f a)) (\{m} l r. ap (ap (pure node) l) r)));
let maybeO : Bit -> Maybe Unit = \b. b (Maybe Unit) nothing (just tt);
--ltreeTrav {S=Maybe} (\traverse. traverse {app=maybeApp} maybeO (initWord (si zi)))

let mapM : {F}{trav : Trav F}{M}{monad : Monad M}{B A} -> (A -> M B) -> F A -> M (F B)
    = \{F}{trav}{M}{monad} f as. trav M (\traverse. traverse {app=monadApp monad} f as);
--run {List Bit} (mapM {trav=listTrav}{monad=contMonad}
--    (\b. cont (\k. k (not b))) (cons I (cons O nil))) id


-- Alternative / MonadPlus

let Alt : (U -> U) -> U
    = \F. {T} -> ((empty : {A} -> F A) -> (alt : {A} -> F A -> F A -> F A) -> F T) -> F T;
let maybeAlt : Alt Maybe
    = \A. A nothing (\lm rm. lm _ (rm _ nothing just) just);
--maybeAlt (\empty alt. alt empty (just zero))


-- Kan extensions

let Yoneda : (U -> U) -> U -> U
    = \F A. {Z} -> ((runYoneda : {B} -> (A -> B) -> F B) -> F Z) -> F Z;
let yonedaFunctor : {G : U -> U} -> Functor (Yoneda G)
    = \F. F (\f y Y. Y (\{B} ab. y {B} (\runY. runY {B} (comp ab f))));
--let ymn : Yoneda Maybe Nat = \Y. Y (\k. just (k zero));
--(yonedaFunctor {Maybe}{Bit} (\map. map (\n. n Bit (\_. I) O) ymn))
--    {Nat} (\runY. runY (\b. b Nat (suc zero) zero))

let Coyoneda : (U -> U) -> U -> U
    = \F A. {Z} -> ({B} -> (B -> A) -> F B -> F Z) -> F Z;
let coyonedaFunctor : {G : U -> U} -> Functor (Coyoneda G)
    = \F. F (\f cy CY. cy (\{B} g v. CY {B} (comp f g) v));
--let cymn : Coyoneda Maybe Bit = \CY. CY {Nat} (\n. n Bit (\_. I) O) (just zero);
--maybeFunctor (\map. cymn map)


let Codensity : (U -> U) -> U -> U
    = \F A. {Z} -> ((runCodensity : {B} -> (A -> F B) -> F B) -> F Z) -> F Z;
--let cdmn : Codensity Maybe Nat = \CD. CD (\k. k (suc zero));

let codensityFunctor : {G : U -> U} -> Functor (Codensity G)
    = \F. F (\f cd CD. CD (\{B} mf. cd {B} (\runCD. runCD {B} (comp mf f))));
--(codensityFunctor {Maybe}{Bit} (\map. map (\n. n Bit (\_. I) O) cdmn))
--    {Nat} (\runCD. runCD (\b. b (Maybe Nat) (just zero) nothing))

let codensityApp : {G : U -> U} -> App (Codensity G)
    = \A. A (\a CD. CD (\k. k a)) (\cdf cda CD. CD (\k. cda (\runA. runA (\a. cdf (\runF. runF (\f. k (f a)))))));
--codensityApp {Maybe}{Bit} (\pure ap. ap (pure eqz) cdmn)

let codensityMonad : {G : U -> U} -> Monad (Codensity G)
    = \M. M (\a CD. CD (\k. k a)) (\cda mf CD. CD (\k. cda (\runA. runA (\a. (mf a) (\runFA. runFA k)))));
--(codensityMonad {Maybe}{Nat} (\ret bind. bind cdmn (comp ret pred)))
--    {Nat} (\runCD. runCD maybeNonzero)



---------------
-- Reasoning --
---------------

-- Leibniz Equality

let Eq : {T} -> T -> T -> U                           = \{T} x y. (P : T -> U) -> P x -> P y;
let refl : {T t} -> Eq {T} t t                        = \P pt. pt;
let trans : {T}{x y z : T} -> Eq y z -> Eq x y -> Eq {T} x z = \yz xy P px. yz P (xy P px);
let sym : {T}{x y : T} -> Eq x y -> Eq {T} y x        = \{T}{x} xy P. xy (\z. P z -> P x) (refl {T} P);
let cong : {A B x y}(f : A -> B) -> Eq x y -> Eq {B} (f x) (f y) = \f xy P. xy (\x. P (f x));
let cong2 : {A B C x y u v}(op : A -> B -> C) -> Eq x y -> Eq {B} u v -> Eq {C} (op x u) (op y v)
    = \{y=y}{u=u} op xy uv P pxuyv. uv (\u. P (op y u)) (xy (\x. P (op x u)) pxuyv);
let subst : {T}{x y : T}(P : T -> U) -> Eq x y -> P x -> P y = \P xy. xy P;

let step : {A}(x : A){y : A} -> Eq x y -> Eq {A} x y  = \_ xy. xy;
let stepAs : {A}(x : A){y z : A} -> Eq x y -> Eq y z -> Eq {A} x z = \_ xy yz. trans yz xy;
let qed : {A}(x : A) -> Eq {A} x x                    = \_. refl;

let EqIsEquiv : {T} -> IsEquivalence {T} Eq           = \E. E refl sym trans;
--EqIsEquiv {E = {x} -> Eq {Bit} x x} (\refl sym trans. refl)
let EqSetoid : {T} -> Setoid {T}                      = \S. S Eq (\E. E refl sym trans);
-- EqSetoid {Nat} (\Rel IsEquiv. IsEquiv (\refl sym trans. refl))


-- Less than or equal to

let Leq : Nat -> Nat -> U
    = \m n. (LE : Nat -> Nat -> U) -> ({a b} -> LE a b -> LE (suc a) (suc b)) -> ({n} -> LE zero n) -> LE m n;
let ls : {m n} -> Leq m n -> Leq (suc m) (suc n)      = \leq LE s z. s (leq LE s z);
let lz : {n} -> Leq zero n                            = \LE s z. z;

let leqRefl : {m n}{mi : NatInd {m}} -> Eq {Nat} m n -> Leq m n
    = \{m}{mi=mi} mne. mne (\l. Leq m l) (mi (\k. Leq k k) (\{k} acc. ls {k}{k} acc) (lz {zero}));


-- Nullary Relations

let neg : U -> U                                      = \P. P -> Bot;
let contradiction : {P Q} -> P -> neg P -> Q          = \p notp. exfalso (notp p);

let Reflects : U -> Bit -> U                          = \P b. (R : Bit -> U) -> (P -> R I) -> (neg P -> R O) -> R b;
let ofyes : {P} -> P -> Reflects P I                  = \p R y n. y p;
let ofno : {P} -> neg P -> Reflects P O               = \negp R y n. n negp;

let Dec : (P : U) -> U
    = \P. {D} -> ((does : Bit) -> (proof : Reflects P does) -> D) -> D;
let because : {P} -> (does : Bit) -> Reflects P does -> Dec P
    = \does proof D. D does proof;
let yes : {P} -> P -> Dec P                           = \p. because I (ofyes p);
let no : {P} -> neg P -> Dec P                        = \negp. because O (ofno negp);

let Decidable : {A B} -> (A -> B -> U) -> U           = \{A}{B} Rel. (x : A)(y : B) -> Dec (Rel x y);


-- Unary Relations

let EmptySet : {A} -> A -> U                          = \_. Bot;
let UniversalSet : {A} -> A -> U                      = \_. Unit;
let Member : {A} -> A -> (A -> U) -> U                = \x P. P x;
let NonMember : {A} -> A -> (A -> U) -> U             = \x P. neg (Member x P);
let Complement : {A} -> (A -> U) -> A -> U            = \P x. neg (Member x P);
let Between : {A} -> (A -> U) -> (A -> U) -> U
    = \P Q. Exists (\x. Pair (Member x P) (Member x Q));
let Subset : {A} -> (A -> U) -> (A -> U) -> U         = \P Q. {x} -> Member x P -> Member x Q;
let Empty : {A} -> (A -> U) -> U                      = \P. {x} -> neg (Member x P);
let Universal : {A} -> (A -> U) -> U                  = \P. {x} -> Member x P;
let ImplPred : {A} -> (A -> U) -> (A -> U) -> A -> U  = \P Q x. Member x P -> Member x Q;
let Assert : {A B} -> (A -> B) -> (B -> U) -> A -> U  = \f P x. P (f x);

-- Predicate Transformer
let PT : U -> U -> U                                  = \A B. (A -> U) -> B -> U;
let Pt : U -> U                                       = \A. (A -> U) -> A -> U;
let skip : {A} -> Pt A                                = \P. P;
let abort : {A B} -> PT A B                           = \{B=B} _. EmptySet {B};
let magic : {A B} -> PT A B                           = \{B=B} _. UniversalSet {B};

let Update : {A B} -> (A -> B) -> PT B A              = \f P x. P (f x);
let AngelicUpdate : {A B} -> (A -> B -> U) -> PT B A  = \R P x. Between (R x) P;
let DemonicUpdate : {A B} -> (A -> B -> U) -> PT B A  = \R P x. Subset (R x) P;

let PFunctor : {I J} -> PT I J -> U
    = \{I}{J} F. {T : I -> U}{j : J} ->
        ((map : {P Q : I -> U} -> Subset P Q -> Subset (F P) (F Q)) -> F T j) -> F T j;


-- Binary Relations

let Implies : {A B} -> (A -> B -> U) -> (A -> B -> U) -> U
    = \P Q. {x y} -> P x y -> Q x y;
let Preserves : {A B} -> (A -> B) -> (A -> A -> U) -> (B -> B -> U) -> U
    = \f P Q. {x y} -> P x y -> Q (f x) (f y);
let BinPreserves : {A B C} -> (A -> B -> C) -> (A -> A -> U) -> (B -> B -> U) -> (C -> C -> U) -> U
    = \op P Q R. {x y u v} -> P x y -> Q u v ->  R (op x u) (op y v);

let Respects : {A B} -> (A -> U) -> (B -> U) -> (A -> B -> U) -> U
    = \P Q Rel. {x y} -> Rel x y -> P x -> Q y;
let Substitutive : {A} -> (A -> A -> U) -> U
    = \{A} Rel. (P : A -> U) -> Respects P P Rel;

let Reflexive : {A} -> (A -> A -> U) -> U             = \Rel. {x} -> Rel x x;
let reflexive : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Reflexive Rel -> Reflexive (on Rel f)
    = \_ _ refl. refl;

let Symmetric : {A} -> (A -> A -> U) -> U             = \Rel. {x y} -> Rel x y -> Rel y x;
let symmetric : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Symmetric Rel -> Symmetric (on Rel f)
    = \_ _ sym. sym;

let Transitive : {A} -> (A -> A -> U) -> U            = \Rel. {i j k} -> Rel j k -> Rel i j -> Rel i k;
let transitive : {A B} -> (f : B -> A) -> (Rel : A -> A -> U) -> Transitive Rel -> Transitive (on Rel f)
    = \_ _ trans. trans;


let IsEquivalence : {A} -> (A -> A -> U) -> U
    = \{A} Rel. {E} -> ((refl : Reflexive {A} Rel)
        (sym : Symmetric {A} Rel)(trans : Transitive {A} Rel) -> E) -> E;
let isEquivalence : {A B}(f : B -> A)(Rel : A -> A -> U) -> IsEquivalence Rel -> IsEquivalence (on Rel f)
    = \f Rel eq E. eq (\refl sym trans. E
        (reflexive f Rel refl) (symmetric f Rel sym) (transitive f Rel trans));

let IsDecEquivalence : {A} -> (A -> A -> U) -> U
    = \{A} Rel. {D} -> ((DecRel : Decidable {A}{A} Rel)(isEquiv : IsEquivalence {A} Rel) -> D) -> D;
let decidable : {A B}(f : B -> A)(Rel : A -> A -> U) -> Decidable Rel -> Decidable (on Rel f)
    = \f _ dec x y. dec (f x) (f y);
let isDecEquivalence
    : {A B}(f : B -> A)(Rel : A -> A -> U) -> IsDecEquivalence Rel -> IsDecEquivalence (on Rel f)
    = \f Rel deq DE. deq (\DecRel isEquiv. DE (decidable f Rel DecRel) (isEquivalence f Rel isEquiv));


let Setoid : {A}{Rel : A -> A -> U} -> U
    = \{Rel=Rel}. {S : {T} -> (T -> T -> U) -> U} -> ({T}(rel : T -> T -> U)
        (isEquiv : IsEquivalence {T} rel) -> S rel) -> S Rel;
let DecSetoid : {A}{Rel : A -> A -> U} -> U
    = \{Rel=Rel}. {D : {T} -> (T -> T -> U) -> U} -> ({T}(rel : T -> T -> U)
        (isDecEquiv : IsDecEquivalence {T} rel) -> D rel) -> D Rel;


-- Operations

let Congruent : {A}(Rel : A -> A -> U)(f : A -> A) -> U
    = \Rel f. Preserves f Rel Rel;
let BinCongruent : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \Rel op. BinPreserves op Rel Rel Rel;

let Identity : {A}(Rel : A -> A -> U)(op : A -> A -> A)(e : A) -> U
    = \Rel op e. Pair ({x} -> Rel (op e x) x) ({x} -> Rel (op x e) x);
let Associative : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \Rel op. {x y z} -> Rel (op (op x y) z) (op x (op y z));
let Commutative : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \Rel op. {x y} -> Rel (op x y) (op y x);
let Idempotent : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \Rel op. {x} -> Rel (op x x) x;
let Absorbs : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \Rel op1 op2. {x}{y} -> Rel (op1 x (op2 x y)) x;
let Absorptive : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \Rel op1 op2. Pair (Absorbs Rel op1 op2) (Absorbs Rel op2 op1);

let LeftDistributesOver : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \Rel op1 op2. {x y z} -> Rel (op1 x (op2 y z)) (op2 (op1 x y) (op1 x z));
let RightDistributesOver : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \Rel op1 op2. {x y z} -> Rel (op1 (op2 y z) x) (op2 (op1 y x) (op1 z x));
let DistributesOver : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \Rel op1 op2. Pair (LeftDistributesOver Rel op1 op2) (RightDistributesOver Rel op1 op2);

let LeftInverse : {A}(Rel : A -> A -> U)(op : A -> A -> A)(inv : A -> A)(e : A) -> U
    = \Rel op inv e. {x} -> Rel (op (inv x) x) e;
let RightInverse : {A}(Rel : A -> A -> U)(op : A -> A -> A)(inv : A -> A)(e : A) -> U
    = \Rel op inv e. {x} -> Rel (op x (inv x)) e;
let Inverse : {A}(Rel : A -> A -> U)(op : A -> A -> A)(inv : A -> A)(e : A) -> U
    = \Rel op inv e. Pair (LeftInverse Rel op inv e) (RightInverse Rel op inv e);


-- Algebras

let IsMagma : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \{A} Rel op. {M} -> ((isEquiv : IsEquivalence {A} Rel)(opcong : BinCongruent Rel op) -> M) -> M;
let Magma : {A}{Rel : A -> A -> U}{op : A -> A -> A} -> U
    = \{A}{Rel}{Op}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}(isMagma : IsMagma {C} rel op) -> M rel op) -> M Rel Op;

let IsUnitalMagma : {A}(Rel : A -> A -> U)(op : A -> A -> A)(e : A) -> U
    = \{A} Rel op e. {UM} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(identity : Identity Rel op e) -> UM) -> UM;
let UnitalMagma : {A}{Rel : A -> A -> U}{op : A -> A -> A}{e : A} -> U
    = \{A}{Rel}{Op}{E}. {UM : {T} -> (T -> T -> U) -> (T -> T -> T) -> T -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}{e : C}(isUnitalMagma : IsUnitalMagma {C} rel op e) -> UM rel op e) -> UM Rel Op E;

let IsSemigroup : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \{A} Rel op. {M} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(assoc : Associative {A} Rel op) -> M) -> M;
let Semigroup : {A}{Rel : A -> A -> U}{op : A -> A -> A} -> U
    = \{A}{Rel}{Op}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}(isSemigroup : IsSemigroup {C} rel op) -> M rel op) -> M Rel Op;

let IsMonoid : {A}(Rel : A -> A -> U)(op : A -> A -> A)(e : A) -> U
    = \{A} Rel op e. {M} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(identity : Identity Rel op e)(assoc : Associative {A} Rel op) -> M) -> M;
let Monoid : {A}{Rel : A -> A -> U}{op : A -> A -> A}{e : A} -> U
    = \{A}{Rel}{Op}{E}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> T -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}{e : C}(isMonoid : IsMonoid {C} rel op e) -> M rel op e) -> M Rel Op E;

let IsCommMonoid : {A}(Rel : A -> A -> U)(op : A -> A -> A)(e : A) -> U
    = \{A} Rel op e. {CM} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(identity : Identity Rel op e)(assoc : Associative {A} Rel op)
        (comm : Commutative {A} Rel op) -> CM) -> CM;
let CommMonoid : {A}{Rel : A -> A -> U}{op : A -> A -> A}{e : A} -> U
    = \{A}{Rel}{Op}{E}. {CM : {T} -> (T -> T -> U) -> (T -> T -> T) -> T -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}{e : C}(isCommMonoid : IsCommMonoid {C} rel op e) -> CM rel op e) -> CM Rel Op E;

let IsIdemCommMonoid : {A}(Rel : A -> A -> U)(op : A -> A -> A)(e : A) -> U
    = \{A} Rel op e. {ICM} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(identity : Identity Rel op e)(assoc : Associative {A} Rel op)
        (comm : Commutative {A} Rel op)(idem : Idempotent {A} Rel op) -> ICM) -> ICM;
let IdemCommMonoid : {A}{Rel : A -> A -> U}{op : A -> A -> A}{e : A} -> U
    = \{A}{Rel}{Op}{E}. {ICM : {T} -> (T -> T -> U) -> (T -> T -> T) -> T -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}{e : C}(isIdemCommMonoid : IsIdemCommMonoid {C} rel op e) -> ICM rel op e) -> ICM Rel Op E;

let IsBand : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \{A} Rel op. {M} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(assoc : Associative {A} Rel op)(idem : Idempotent {A} Rel op) -> M) -> M;
let Band : {A}{Rel : A -> A -> U}{op : A -> A -> A} -> U
    = \{A}{Rel}{Op}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}(isBand : IsBand {C} rel op) -> M rel op) -> M Rel Op;

let IsSemilattice : {A}(Rel : A -> A -> U)(op : A -> A -> A) -> U
    = \{A} Rel op. {M} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong : BinCongruent Rel op)(assoc : Associative {A} Rel op)(comm : Commutative {A} Rel op)(idem : Idempotent {A} Rel op) -> M) -> M;
let Semilattice : {A}{Rel : A -> A -> U}{op : A -> A -> A} -> U
    = \{A}{Rel}{Op}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op : C -> C -> C}(isSemilattice : IsSemilattice {C} rel op) -> M rel op) -> M Rel Op;

let IsLattice : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \{A} Rel op1 op2. {M} -> ((isEquiv : IsEquivalence {A} Rel)
        (opcong1 : BinCongruent Rel op1)(assoc1 : Associative {A} Rel op1)(comm1 : Commutative {A} Rel op1)
        (opcong2 : BinCongruent Rel op2)(assoc2 : Associative {A} Rel op2)(comm2 : Commutative {A} Rel op2)
        (absorp : Absorptive Rel op1 op2) -> M) -> M;
let Lattice : {A}{Rel : A -> A -> U}{op1 op2 : A -> A -> A} -> U
    = \{A}{Rel}{Op1}{Op2}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op1 op2 : C -> C -> C}(isLattice : IsLattice {C} rel op1 op2) -> M rel op1 op2) -> M Rel Op1 Op2;

let IsDistributiveLattice : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A) -> U
    = \{A} Rel op1 op2. {M} -> ((isLattice : IsLattice {A} Rel op1 op2)
        (distrib12 : DistributesOver Rel op1 op2)(distrib21 : DistributesOver Rel op2 op1) -> M) -> M;
let DistributiveLattice : {A}{Rel : A -> A -> U}{op1 op2 : A -> A -> A} -> U
    = \{A}{Rel}{Op1}{Op2}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> (T -> T -> T) -> U} ->
        ({C}{rel : C -> C -> U}{op1 op2 : C -> C -> C}(isDistributiveLattice : IsDistributiveLattice {C} rel op1 op2) -> M rel op1 op2) -> M Rel Op1 Op2;

let IsBooleanAlgebra : {A}(Rel : A -> A -> U)(op1 op2 : A -> A -> A)(inv : A -> A)(top bot : A) -> U
    = \{A} Rel op1 op2 inv top bot. {M} -> ((isLattice : IsLattice {A} Rel op1 op2)
        (distrib12 : DistributesOver Rel op1 op2)(distrib21 : DistributesOver Rel op2 op1)
        (op1compl : Inverse Rel op1 inv top)(op2compl : Inverse Rel op2 inv bot)(invcong : Congruent Rel inv) -> M) -> M;
let BooleanAlgebra : {A}{Rel : A -> A -> U}{op1 op2 : A -> A -> A}{inv : A -> A}{top bot : A} -> U
    = \{A}{Rel}{Op1}{Op2}{Inv}{Top}{Bott}. {M : {T} -> (T -> T -> U) -> (T -> T -> T) -> (T -> T -> T) -> (T -> T) -> T -> T -> U} ->
        ({C}{rel : C -> C -> U}{op1 op2 : C -> C -> C}{inv : C -> C}{top bot : C}
        (isBooleanAlgebra : IsBooleanAlgebra {C} rel op1 op2 inv top bot) -> M rel op1 op2 inv top bot) -> M Rel Op1 Op2 Inv Top Bott;


-- Reflexive-Transitive Closure

let Const : {A B} -> U -> A -> B -> U = \I _ _. I;
let Always : {A B} -> A -> B -> U = Const Unit;

let Star : {A}{a b : A} -> (A -> A -> U) -> U
    = \{A}{a}{b} T. (S : (A -> A -> U) -> A -> A -> U) ->
        (empty : {i : A} -> S T i i)
        (rel : {i j k : A}(x : T i j)(xs : S T j k) -> S T i k) -> S T a b;

let StarList : U -> U = \A. Star (Const A);
let starNil : {A} -> StarList A = \S empty rel. empty;
let starCons : {A} -> A -> StarList A -> StarList A = \a as S empty rel. rel a (as S empty rel);
-- starCons O starNil

let StarNat : U = Star Always;
let starZero : StarNat = \S empty rel. empty;
let starSuc : StarNat -> StarNat = \n S empty rel. rel _ (n S empty rel);
--starSuc (starSuc starZero)


-- Rational Numbers

let TypeBit : Bit -> U                                = \b. b U Unit Void;
let NonZero : Nat -> U
    = \n. (N : U) -> (nonZ : TypeBit (not (eqz n)) -> N) -> N;
let oneNotZero : NonZero (suc zero)                   = \N nonZ. nonZ tt;

let RawRatio : U
    = (R : U) -> ((num : Nat) -> (predDen : Nat) -> R) -> R;
let rawRatio : Nat -> Nat -> RawRatio                 = \m n R r. r m n;
let rawNum : RawRatio -> Nat                          = \r. r Nat (\m n. m);
let rawDen : RawRatio -> Nat                          = \r. r Nat (\m n. suc n);
let RawRatioNonZero : RawRatio -> U                   = comp NonZero rawNum;

let Divs : Nat -> Nat -> U
    = \m n. {D : Nat -> Nat -> U} -> ({a b : Nat} -> (quot : Nat) -> Eq {Nat} (mul quot a) b -> D a b) -> D m n;
let Coprime : Nat -> Nat -> U
    = \m n. {d : Nat} -> Pair (Divs d m) (Divs d n) -> Eq d (suc zero);
let Ratio : U
    = {R : U} -> ((num : Nat) -> (predDen : Nat) -> Coprime num (suc predDen) -> R) -> R;

let mulRightIden : {n : Nat}{ni : NatInd {n}} -> Eq {Nat} (mul n (suc zero)) n
    = \{n}{ni}. ni (\n. Eq {Nat} (mul n (suc zero)) n) (cong suc) refl;
let oneDividesAnyNat : {n : Nat} -> Divs (suc zero) n
    = \{n} divs. divs {suc zero} n (mulRightIden {n});



-----------------------
-- Dependent Records --
-----------------------

-- Dependent Sums

let Sigma : (A : U)(B : A -> U){a : A} -> U
    = \A B {a}. (S : A -> U) -> ((fst : A)(snd : B fst) -> S fst) -> S a;
let dpair : {A}{B : A -> U}(a : A)(b : B a) -> Sigma A B {a}
    = \a b S s. s a b;
let proj1 : {A}{B : A -> U}{a : A} -> Sigma A B {a} -> A
    = \{A} s. s (\_. A) (\fst snd. fst);
let proj2 : {A}{B : A -> U}{a : A} -> Sigma A B {a} -> B a
    = \{B=B} s. s B (\fst snd. snd);
let smap
    : {A B}{P : A -> U}{Q : B -> U}(f : A -> B){a : A} -> ({x} -> P x -> Q (f x)) -> Sigma A P {a} -> Sigma B Q {f a}
    =\{B=B}{Q=Q} f g s. s (\a. Sigma B Q {f a}) (\x y. dpair (f x) (g y));

let Exists : {A}(B : A -> U){a : A} -> U              = \B {a}. Sigma _ B {a};

let Prod : (A B : U){a : A} -> U = \A B {a}. Sigma A (const B) {a};
let ndpair : {A B}(a : A)(b : B) -> Prod A B {a}
    = \a b S s. s a b;
let smapProj1 : {A B C}(f : A -> B){a} -> Prod A C {a} -> Prod B C {f a}
    = \{A}{B}{C} f. smap {A}{B}{const C}{const C} f id;
let smapProj2 : {A}{B C : A -> U}(f : {x} -> B x -> C x){a : A} -> Sigma A B {a} -> Sigma A C {a}
    = \{A}{B}{C} f. smap {A}{A}{B}{C} id f;


-- Containers

let Container : {Sh} -> U
    = \{Sh}. (C : U -> U) -> ((Shape : U)(Position : Shape -> U) -> C Shape) -> C Sh;
let cpair : (Sh : U)(Pos : Sh -> U) -> Container {Sh}
    = \Sh Pos C c. c Sh Pos;
let cshape : {Sh} -> Container {Sh} -> U
    = \c. c (\_. U) (\sh pos. sh);
let cposition : {Sh} -> Container {Sh} -> Sh -> U
    = \c. c (\sh. sh -> U) (\sh pos. pos);
let cextend : {Sh}{sh : Sh} -> Container {Sh} -> U -> U
    = \{Sh}{sh} C X. Sigma Sh (\s. (cposition {Sh} C) s -> X) {sh};
let cmap : {Sh}{C : Container {Sh}}{X Y}(f : X -> Y){sh : Sh} -> (cextend {Sh}{sh} C) X -> (cextend {Sh}{sh} C) Y
    = \{Sh}{C}{X}{Y} f {sh}. smapProj2 {Sh}{\s. (cposition {Sh} C) s -> X}{\s. (cposition {Sh} C) s -> Y} (comp f) {sh};

--proj2 (tt (cextend (cpair Nat (\n. Fin {n})) Bool)
--    (dpair (suc (suc zero)) (\fn. listLookup (cons true (cons false nil)) fn))) (fz)
--proj2 (cmap {C=cpair Nat (\n. Fin {n})} eqz
--    (dpair (suc (suc zero)) (\fn. listLookup (cons (suc zero) (cons zero nil)) fn))) (fz)

let ListC : U -> U
    = \A. cextend (cpair Nat (\n. Fin {n})) A;
let nilC : {A} -> ListC A
    = \{A}. dpair zero (absurd _);
--let consC : {A} -> A -> ListC A -> ListC A
--    = \{A} a asC. asC (\_. ListC A)
--        (\(n : Nat)(fxs : Fin {n} -> A). dpair {Nat}{\n. Fin {n} -> A} (suc n)
--            (\(fsn : Fin {suc n}). fsn (\n. A) fxs a));


let CMorphism : {Sh1 Sh2}(C1 C2 : Container){Sf} -> U
    = \{Sh1}{Sh2} C1 C2 {Sf}. {M : (sh1 sh2 : U) -> Container {sh1} -> Container {sh2} -> (sh1 -> sh2) -> U} ->
        ({sh1 sh2 c1 c2}(sf : sh1 -> sh2)(pf : {s} -> (cposition c2) (sf s) -> (cposition c1) s) ->
        M sh1 sh2 c1 c2 sf) -> M Sh1 Sh2 C1 C2 Sf;
let cmpair : {Sh1 Sh2 C1 C2}(Sf : Sh1 -> Sh2) -> ({s} -> (cposition C2) (Sf s) -> (cposition C1) s) -> CMorphism C1 C2
    = \{Sh1}{Sh2}{C1}{C2} Sf Pf CM. CM {Sh1}{Sh2}{C1}{C2} Sf Pf;
let cmshape : {Sh1 Sh2 C1 C2} -> CMorphism C1 C2 -> Sh1 -> Sh2
    = \CM. CM {\sh1 sh2 _ _ _. sh1 -> sh2} (\sf pf. sf);
let cmposition : {C1 C2 Sf} -> CMorphism C1 C2 {Sf} -> {s} -> (cposition C2) (Sf s) -> (cposition C1) s
    = \CM. CM {\_ _ c1 c2 sf. {s} -> (cposition c2) (sf s) -> (cposition c1) s} (\sf pf. pf);
let cmextend : {X Sh1 Sh2 C1 C2 Sf} -> CMorphism C1 C2 {Sf} -> (cextend C1) X -> (cextend C2) X
    = \{X} CM. CM {\_ _ c1 c2 _. {s} -> (cextend c1) X -> (cextend c2) X} (\sf pf. smap sf (\psx. comp psx pf));

let AllC : (C : Container){X}(P : X -> U)(cx : cextend C X) -> U
    = \C P cx. {A} -> ((proof : {p} -> P (proj2 cx p)) -> A) -> A;
let AnyC : (C : Container){X}(P : X -> U)(cx : cextend C X) -> U
    = \C P cx. {A} -> ((proof : Sigma _ (\p. P (proj2 cx p))) -> A) -> A;


-- W-types

let W : (A : U)(B : A -> U){a : A} -> U
    = \A B {a}. (V : (X : U)(Y : X -> U){x : X} -> U)
        (sup : {X}{Y : X -> U}(sh1 : X)
            (com : Y sh1 -> {sh2} -> V X Y {sh2}) -> V X Y {sh1}) -> V A B {a};
let sup : {A}{B : A -> U}(sh1 : A)(com :B sh1 -> {sh2} -> W A B {sh2}){b : B sh1} -> W A B {sh1}
    = \x a {b}. a b;
let wshape : {A}{B : A -> U}{a : A} -> W A B {a} -> A
--    = \{a=a} _. a;
    = \w. w (\A B. A) (\a b. a);
--let wcomponent : {A}{B : A -> U}{a : A}(w : W A B {a}) -> B (wshape w) -> W A B {a}
--    = \{X}{Y}{x} w. w (\A B {a}. B a -> W A B {a}) (\{A}{B}(a : A)(b : B a -> W A B {a}). b);

let ListWCom : {A} -> Maybe A -> U
    = \m. m U Void (\_. Unit);
let ListW : U -> U
    = \A. W (Maybe A) ListWCom;
let nilW : {A} -> ListW A
    = \{A}. sup {Maybe A}{ListWCom} nothing absurd;
--let consW : {A} -> A -> ListW A -> ListW A
--    = \{A} a asW. sup {Maybe A}{ListWCom} (just a) (\_. asW) {tt};


-- Propositions

let iscontr : U -> U = \A. Sigma A (\a. (x : A) -> Eq {A} a x);
let isprop : U -> U = \A. (x y : A) -> iscontr (Eq {A} x y);
let eqIsContr : {A} -> iscontr A -> {x y : A} -> Eq {A} x y
    = \isC {x}{y}. isC (\_. Eq _ _) (\_ C. trans (C y) (sym (C x)));
let Prop : U = Sigma U isprop;
let typeProp : Prop -> U = proj1;



-----------------
-- Some proofs --
-----------------

-- Concat on list is a monoid

let ListMagma : {T} -> IsMagma {List T} Eq concat -> Magma {List T}
    = \{T} p M. M {List T}{Eq {List T}}{concat} p;
let ListIsMagma : {T} -> IsMagma {List T} Eq concat   = \IsM. IsM EqIsEquiv (cong2 concat);

let ListUnitalMagma : {T} -> IsUnitalMagma {List T} Eq concat nil -> UnitalMagma {List T}
    = \{T} p UM. UM {List T}{Eq {List T}}{concat}{nil} p;
let concatRightIden : {A}{xs : List A}{xsi : ListInd A {xs}} -> Eq {List A} (concat xs nil) xs
    = \{A}{xs}{xsi}. xsi
        (\xs. Eq {List A} (concat xs nil) xs) refl (\a. cong (cons a));
let ListIsUnitalMagma : {T} -> IsUnitalMagma {List T} Eq concat nil
    = \IsUM. ListIsMagma (\IsEquiv opcong. IsUM IsEquiv opcong (pair refl (\{xs}. concatRightIden {xs=xs})));

let ListMonoid : {T} -> IsMonoid {List T} Eq concat nil -> Monoid {List T}
    = \{T} p M. M {List T}{Eq {List T}}{concat}{nil} p;
let concatAssoc
    : {A}{xs ys zs : List A}{xsi : ListInd A {xs}} ->
        Eq {List A} (concat (concat xs ys) zs) (concat xs (concat ys zs))
    = \{A}{xs}{ys}{zs}{xsi}. xsi
        (\xs. Eq {List A} (concat (concat xs ys) zs) (concat xs (concat ys zs)))
        refl (\a. cong (cons a));
let ListIsMonoid : {T} -> IsMonoid {List T} Eq concat nil
    = \IsMon. ListIsUnitalMagma (\IsEquiv opcong iden. IsMon IsEquiv opcong iden (\{xs}. concatAssoc {xs=xs}));
--ListMonoid ListIsMonoid (\IsMon. IsMon (\IsEquiv opcong iden assoc. IsEquiv (\refl sym trans. refl)))

-- Alternative route to Monoid

let ListIsMonoid_ : {T} -> IsMonoid {List T} Eq concat nil
    = \IsMon. IsMon EqIsEquiv (cong2 concat) (pair refl (\{xs}. concatRightIden {xs=xs})) (\{xs}. concatAssoc {xs=xs});
ListMonoid ListIsMonoid_ (\IsMon. IsMon (\IsEquiv opcong iden assoc. IsEquiv (\refl sym trans. refl)))


-- Addition on Nat is a commutative monoid

let NatAddMagma : IsMagma {Nat} Eq add -> Magma {Nat} = \p M. M {Nat}{Eq {Nat}}{add} p;
let NatAddIsMagma : IsMagma {Nat} Eq add = \IsM. IsM EqIsEquiv (cong2 add);
--NatAddMagma NatAddIsMagma (\IsM. IsM (\IsEquiv opcong. IsEquiv (\refl sym trans. refl)))

let NatAddUnitalMagma : IsUnitalMagma {Nat} Eq add zero -> UnitalMagma {Nat} = \p UM. UM {Nat}{Eq {Nat}}{add}{zero} p;
let addRightIden : {n : Nat}{ni : NatInd {n}} -> Eq {Nat} (add n zero) n
    = \{n}{ni}. ni (\n. Eq {Nat} (add n zero) n) (cong suc) refl;
let NatAddIsUnitalMagma : IsUnitalMagma {Nat} Eq add zero
    = \IsUM. NatAddIsMagma (\IsEquiv opcong. IsUM IsEquiv opcong (pair refl addRightIden));
--NatAddUnitalMagma NatAddIsUnitalMagma (\IsUM. IsUM (\IsEquiv opcong iden. IsEquiv (\refl sym trans. refl)))


let NatAddMonoid : IsMonoid {Nat} Eq add zero -> Monoid {Nat} = \p M. M {Nat}{Eq {Nat}}{add}{zero} p;
let addAssoc : {m n p : Nat} -> Eq {Nat} (add (add m n) p) (add m (add n p)) = refl;
let NatAddIsMonoid : IsMonoid {Nat} Eq add zero
    = \IsMon. NatAddIsUnitalMagma (\IsEquiv opcong iden. IsMon IsEquiv opcong iden (\{x}{y}{z}. addAssoc {x}{y}{z}));
--NatAddMonoid NatAddIsMonoid (\IsMon. IsMon (\IsEquiv opcong iden assoc. IsEquiv (\refl sym trans. refl)))

let NatAddCommMonoid : IsCommMonoid {Nat} Eq add zero -> CommMonoid {Nat} = \p CM. CM {Nat}{Eq {Nat}}{add}{zero} p;
let addSuc : (m n : Nat){mi : NatInd {m}} -> Eq (add m (suc n)) (suc (add m n))
    = \m n {mi}. mi (\m. Eq (add m (suc n)) (suc (add m n))) (cong suc) refl;
let addCommSuc
    : {n : Nat}{ni : NatInd {n}}{k} -> Eq (add n k) (add k n) ->
        Eq (add n (suc k)) (add (suc k) n)
    = \{n}{ni}{k} acc.
        stepAs (add n (suc k)) (addSuc n k {ni})
       (stepAs (suc (add n k)) (cong suc acc)
       (qed (add (suc k) n)));
let addComm : {m n : Nat}{mi : NatInd {m}}{ni : NatInd {n}} -> Eq (add m n) (add n m)
    = \{m}{n}{mi}{ni}. ni (\n. Eq {Nat} (add m n) (add n m)) (addCommSuc {m}{mi}) (addRightIden {m}{mi});
let NatAddIsCommMonoid : IsCommMonoid {Nat} Eq add zero = \IsMon. NatAddIsMonoid
    (\IsEquiv opcong iden assoc. IsMon IsEquiv opcong iden (\{x}{y}{z}. assoc {x}{y}{z}) (\{x}{y}. addComm {x}{y}));
--NatAddCommMonoid NatAddIsCommMonoid (\IsCM. IsCM (\IsEquiv opcong iden assoc comm. IsEquiv (\refl sym trans. refl)))

-- Alternative route to Monoid

let NatAddSemigroup : IsSemigroup {Nat} Eq add -> Semigroup {Nat} = \p SG. SG {Nat}{Eq {Nat}}{add} p;
let NatAddIsSemigroup : IsSemigroup {Nat} Eq add
    = \IsSG. NatAddIsMagma (\IsEquiv opcong. IsSG IsEquiv opcong (\{x}{y}{z}. addAssoc {x}{y}{z}));
--NatAddSemigroup NatAddIsSemigroup (\IsSG. IsSG (\IsEquiv opcong assoc. IsEquiv (\refl sym trans. refl)))

let NatAddIsMonoid_ : IsMonoid {Nat} Eq add zero
    = \IsMon. NatAddIsSemigroup
        (\IsEquiv opcong assoc. IsMon IsEquiv opcong (pair refl addRightIden) (\{x}{y}{z}. assoc {x}{y}{z}));
--NatAddMonoid NatAddIsMonoid_ (\IsMon. IsMon (\IsEquiv opcong iden assoc. IsEquiv (\refl sym trans. refl)))


-- Boolean Algebra

let MeetMagma : IsMagma {Bool} Eq and -> Magma {Bool} = \p M. M {Bool}{Eq {Bool}}{and} p;
let MeetIsMagma : IsMagma {Bool} Eq and = \IsM. IsM EqIsEquiv (cong2 and);
--MeetMagma MeetIsMagma (\IsM. IsM (\IsEquiv opcong. IsEquiv (\refl sym trans. refl)))

let MeetSemigroup : IsSemigroup {Bool} Eq and -> Semigroup {Bool} = \p SG. SG {Bool}{Eq {Bool}}{and} p;
let andAssoc : {m n p : Bool}{bi : BoolInd {m}} -> Eq {Bool} (and (and m n) p) (and m (and n p))
    = \{m}{n}{p}{bi}. bi (\b. Eq {Bool} (and (and b n) p) (and b (and n p))) refl refl;
let MeetIsSemigroup : IsSemigroup {Bool} Eq and
    = \IsSG. MeetIsMagma (\IsEquiv opcong. IsSG IsEquiv opcong (\{x}{y}{z}. andAssoc {x}{y}{z}));
--MeetSemigroup MeetIsSemigroup (\IsSG. IsSG (\IsEquiv opcong assoc. IsEquiv (\refl sym trans. refl)))

let MeetBand : IsBand {Bool} Eq and -> Band {Bool} = \p B. B {Bool}{Eq {Bool}}{and} p;
let andIdemp : {b : Bool}{bi : BoolInd {b}} -> Eq {Bool} (and b b) b
    = \{bi=bi}. bi (\b. Eq {Bool} (and b b) b) refl refl;
let MeetIsBand : IsBand {Bool} Eq and
    = \IsB. MeetIsSemigroup (\IsEquiv opcong assoc. IsB IsEquiv opcong (\{x}{y}{z}. assoc {x}{y}{z}) (\{x}. andIdemp {x}));
--MeetBand MeetIsBand (\IsB. IsB (\IsEquiv opcong assoc idemp. IsEquiv (\refl sym trans. refl)))

let MeetSemilattice : IsSemilattice {Bool} Eq and -> Semilattice {Bool} = \p SL. SL {Bool}{Eq {Bool}}{and} p;
let andComm : {a b : Bool}{ai : BoolInd {a}}{bi : BoolInd {b}} -> Eq {Bool} (and a b) (and b a)
    = \{a}{b}{ai}{bi}. ai (\c. Eq {Bool} (and c b) (and b c))
        (bi (\d. Eq {Bool} d (and d true)) refl refl)
        (bi (\d. Eq {Bool} false (and d false)) refl refl);
let MeetIsSemilattice : IsSemilattice {Bool} Eq and
    = \IsSL. MeetIsBand (\IsEquiv opcong assoc idemp. IsSL IsEquiv opcong (\{x}{y}{z}. assoc {x}{y}{z}) (\{x}{y}. andComm {x}{y}) (\{x}. idemp {x}));
--MeetSemilattice MeetIsSemilattice (\IsSL. IsSL (\IsEquiv opcong assoc comm idemp. IsEquiv (\refl sym trans. refl)))

let MeetIsSemilattice_ : IsSemilattice {Bool} Eq and
    = \IsSL. IsSL EqIsEquiv (cong2 and) (\{x}{y}{z}. andAssoc {x}{y}{z}) (\{x}{y}. andComm {x}{y}) (\{x}. andIdemp {x});
--MeetSemilattice MeetIsSemilattice_ (\IsSL. IsSL (\IsEquiv opcong assoc comm idemp. IsEquiv (\refl sym trans. refl)))


let JoinMagma : IsMagma {Bool} Eq or -> Magma {Bool} = \p M. M {Bool}{Eq {Bool}}{or} p;
let JoinIsMagma : IsMagma {Bool} Eq or = \IsM. IsM EqIsEquiv (cong2 or);
--JoinMagma JoinIsMagma (\IsM. IsM (\IsEquiv opcong. IsEquiv (\refl sym trans. refl)))

let JoinSemigroup : IsSemigroup {Bool} Eq or -> Semigroup {Bool} = \p SG. SG {Bool}{Eq {Bool}}{or} p;
let orAssoc : {m n p : Bool}{bi : BoolInd {m}} -> Eq {Bool} (or (or m n) p) (or m (or n p))
    = \{m}{n}{p}{bi}. bi (\b. Eq {Bool} (or (or b n) p) (or b (or n p))) refl refl;
let JoinIsSemigroup : IsSemigroup {Bool} Eq or
    = \IsSG. JoinIsMagma (\IsEquiv opcong. IsSG IsEquiv opcong (\{x}{y}{z}. orAssoc {x}{y}{z}));
--JoinSemigroup JoinIsSemigroup (\IsSG. IsSG (\IsEquiv opcong assoc. IsEquiv (\refl sym trans. refl)))

let JoinBand : IsBand {Bool} Eq or -> Band {Bool} = \p B. B {Bool}{Eq {Bool}}{or} p;
let orIdemp : {b : Bool}{bi : BoolInd {b}} -> Eq {Bool} (or b b) b
    = \{bi=bi}. bi (\b. Eq {Bool} (or b b) b) refl refl;
let JoinIsBand : IsBand {Bool} Eq or
    = \IsB. JoinIsSemigroup (\IsEquiv opcong assoc. IsB IsEquiv opcong (\{x}{y}{z}. assoc {x}{y}{z}) (\{x}. orIdemp {x}));
--JoinBand JoinIsBand (\IsB. IsB (\IsEquiv opcong assoc idemp. IsEquiv (\refl sym trans. refl)))

let JoinSemilattice : IsSemilattice {Bool} Eq or -> Semilattice {Bool} = \p SL. SL {Bool}{Eq {Bool}}{or} p;
let orComm : {a b : Bool}{ai : BoolInd {a}}{bi : BoolInd {b}} -> Eq {Bool} (or a b) (or b a)
    = \{a}{b}{ai}{bi}. ai (\c. Eq {Bool} (or c b) (or b c))
        (bi (\d. Eq {Bool} true (or d true)) refl refl)
        (bi (\d. Eq {Bool} d (or d false)) refl refl);
let JoinIsSemilattice : IsSemilattice {Bool} Eq or
    = \IsSL. JoinIsBand (\IsEquiv opcong assoc idemp. IsSL IsEquiv opcong (\{x}{y}{z}. assoc {x}{y}{z}) (\{x}{y}. orComm {x}{y}) (\{x}. idemp {x}));
--JoinSemilattice JoinIsSemilattice (\IsSL. IsSL (\IsEquiv opcong assoc comm idemp. IsEquiv (\refl sym trans. refl)))

let JoinIsSemilattice_ : IsSemilattice {Bool} Eq or
    = \IsSL. IsSL EqIsEquiv (cong2 or) (\{x}{y}{z}. orAssoc {x}{y}{z}) (\{x}{y}. orComm {x}{y}) (\{x}. orIdemp {x});
JoinSemilattice JoinIsSemilattice_ (\IsSL. IsSL (\IsEquiv opcong assoc comm idemp. IsEquiv (\refl sym trans. refl)))


let BoolLattice : IsLattice {Bool} Eq and or -> Lattice {Bool} = \p L. L {Bool}{Eq {Bool}}{and}{or} p;
let andAbsorbsOr : {a b : Bool}{ai : BoolInd {a}} -> Eq {Bool} (and a (or a b)) a
    = \{a}{b}{ai}. ai (\c. Eq {Bool} (and c (or c b)) c) (tt (Eq {Bool} true true) refl) refl;
let orAbsorbsAnd : {a b : Bool}{ai : BoolInd {a}} -> Eq {Bool} (or a (and a b)) a
    = \{a}{b}{ai}. ai (\c. Eq {Bool} (or c (and c b)) c) (tt (Eq {Bool} true true) refl) refl;
let BoolIsLattice : IsLattice {Bool} Eq and or
    = \IsL. IsL EqIsEquiv
        (cong2 and) (\{x}{y}{z}. andAssoc {x}{y}{z}) (\{x}{y}. andComm {x}{y})
        (cong2 or) (\{x}{y}{z}. orAssoc {x}{y}{z}) (\{x}{y}. orComm {x}{y})
        (pair (\{x}{y}. andAbsorbsOr {x}{y}) (\{x}{y}. orAbsorbsAnd {x}{y}));
--BoolLattice BoolIsLttice (\IsSL. IsSL (\IsEquiv opcong1 assoc1 comm1 opcong2 assoc2 comm2 absorp. IsEquiv (\refl sym trans. refl)))

let BoolDistributiveLattice : IsDistributiveLattice {Bool} Eq and or -> DistributiveLattice {Bool} = \p L. L {Bool}{Eq {Bool}}{and}{or} p;
let andLeftDistribOverOr : {a b c : Bool}{ai : BoolInd {a}} -> Eq {Bool} (and a (or b c)) (or (and a b) (and a c))
    = \{a}{b}{c}{ai}. ai (\d. Eq {Bool} (and d (or b c)) (or (and d b) (and d c))) refl refl;
let andRightDistribOverOr : {a b c : Bool}{ai : BoolInd {a}} -> Eq {Bool} (and (or b c) a) (or (and b a) (and c a))
    = \{a}{b}{c}{ai}.
         stepAs (and (or b c) a) (andComm {or b c}{a})
        (stepAs (and a (or b c)) (andLeftDistribOverOr {a}{b}{c})
        (stepAs (or (and a b) (and a c)) (cong2 or (andComm {a}{b}) (andComm {a}{c}))
        (qed (or (and b a) (and c a)))));
let andDistribOverOr : DistributesOver Eq and or = pair (\{x}{y}{z}. andLeftDistribOverOr {x}{y}{z}) (\{x}{y}{z}. andRightDistribOverOr {x}{y}{z});
let orLeftDistribOverAnd : {a b c : Bool}{ai : BoolInd {a}} -> Eq {Bool} (or a (and b c)) (and (or a b) (or a c))
    = \{a}{b}{c}{ai}. ai (\d. Eq {Bool} (or d (and b c)) (and (or d b) (or d c))) refl refl;
let orRightDistribOverAnd : {a b c : Bool}{ai : BoolInd {a}} -> Eq {Bool} (or (and b c) a) (and (or b a) (or c a))
    = \{a}{b}{c}{ai}.
         stepAs (or (and b c) a) (orComm {and b c}{a})
        (stepAs (or a (and b c)) (orLeftDistribOverAnd {a}{b}{c})
        (stepAs (and (or a b) (or a c)) (cong2 and (orComm {a}{b}) (orComm {a}{c}))
        (qed (and (or b a) (or c a)))));
let orDistribOverAnd : DistributesOver Eq or and = pair (\{x}{y}{z}. orLeftDistribOverAnd {x}{y}{z}) (\{x}{y}{z}. orRightDistribOverAnd {x}{y}{z});
let BoolIsDistributiveLattice : IsDistributiveLattice {Bool} Eq and or
    = \IsDL. IsDL BoolIsLattice andDistribOverOr orDistribOverAnd;
--BoolDistributiveLattice BoolIsDistributiveLattice (\IsDL. IsDL (\IsL distrib12 distrib21. IsL
--  (\IsEquiv opcong1 assoc1 comm1 opcong2 assoc2 comm2 absorp. IsEquiv (\refl sym trans. refl))))

let BoolBooleanAlgebra : IsBooleanAlgebra {Bool} Eq and or not false true -> BooleanAlgebra {Bool} = \p L. L {Bool}{Eq {Bool}}{and}{or}{not}{false}{true} p;
let andLeftInverse : {a : Bool}{ai : BoolInd {a}}-> Eq {Bool} (and (not a) a) false
    = \{a}{ai}. ai (\b. Eq {Bool} (and (not b) b) false) refl refl;
let andRightInverse : {a : Bool} -> Eq {Bool} (and a (not a)) false
    = \{a}. trans {Bool} (andLeftInverse {a}) (andComm {a} {not a});
let orLeftInverse : {a : Bool}{ai : BoolInd {a}}-> Eq {Bool} (or (not a) a) true
    = \{a}{ai}. ai (\b. Eq {Bool} (or (not b) b) true) refl refl;
let orRightInverse : {a : Bool} -> Eq {Bool} (or a (not a)) true
    = \{a}. trans {Bool} (orLeftInverse {a}) (orComm {a} {not a});
let BoolIsBooleanAlgebra : IsBooleanAlgebra {Bool} Eq and or not false true
    = \IsBA. IsBA BoolIsLattice andDistribOverOr orDistribOverAnd
        (pair (\{x}. andLeftInverse {x}) (\{x}. andRightInverse {x})) (pair (\{x}. orLeftInverse {x}) (\{x}. orRightInverse {x})) (cong not);
--BoolBooleanAlgebra BoolIsBooleanAlgebra (\IsBA. IsBA (\IsL distrib12 distrib21 op1compl op2compl invcong. IsL
--  (\IsEquiv opcong1 assoc1 comm1 opcong2 assoc2 comm2 absorp. IsEquiv (\refl sym trans. refl))))


-- Foldnat is unrollable

let natIndInFst
    : {A}{f : Nat -> A -> A}{a : A}{n : Nat}{ni : NatInd {n}} ->
        Eq {Nat} (fst (n (Pair Nat A) (\p. pair (suc (fst p)) (f (fst p) (snd p))) (pair zero a))) n
    = \{A}{f}{a}{n}{ni}. ni
        (\n. Eq {Nat} (fst (n (Pair Nat A) (\p. pair (suc (fst p)) (f (fst p) (snd p))) (pair zero a))) n)
        (cong suc) refl;
let unrollFoldnatSuc
    : {A}{f : Nat -> A -> A}{a : A}{n : Nat}{ni : NatInd {n}} ->
        Eq {A} (foldnat f a (suc n))       (f n (foldnat f a n)) ->
        Eq {A} (foldnat f a (suc (suc n))) (f (suc n) (foldnat f a (suc n)))
    = \{A}{f}{a}{n}{ni} acc.
        stepAs (foldnat f a (suc (suc n)))       (cong2 f (cong suc (natIndInFst {A}{f}{a}{n}{ni})) acc)
       (stepAs (f (suc n) (f n (foldnat f a n))) (cong2 f refl (cong2 f (sym (natIndInFst {A}{f}{a}{n}{ni})) refl))
       (qed (f (suc n) (foldnat f a (suc n)))));
let unrollFoldnat
    : {A}{f : Nat -> A -> A}{a : A}{n : Nat}{ni : NatInd {n}} ->
        Eq {A} (foldnat f a (suc n)) (f n (foldnat f a n))
    = \{A}{f}{a}{n}{ni}. snd (proj2 (ni
        (\n. Sigma Nat (\n. Pair (NatInd {n}) (Eq {A} (foldnat f a (suc n)) (f n (foldnat f a n)))) {n})
        (\{k} s. s
          (\m. Sigma Nat (\n. Pair (NatInd {n}) (Eq {A} (foldnat f a (suc n)) (f n (foldnat f a n)))) {suc m})
          (\dfst dsnd. dpair (suc dfst) (pair (si (fst dsnd)) (unrollFoldnatSuc {A}{f}{a}{dfst}{fst dsnd} (snd dsnd)))))
        (dpair zero (pair zi refl))));

let natIndSndIrrelevant
    : {n : Nat}{A : U}{a : A}{f : A -> A}{ni : NatInd {n}} ->
      {W : U}{v y : W}{w x : Pair A W -> W} -> Eq {A}
        (fst (n (Pair A W) (\p. pair (f (fst p)) (w p)) (pair a v)))
        (fst (n (Pair A W) (\p. pair (f (fst p)) (x p)) (pair a y)))
    = \{n}{A}{a}{f}{ni}. ni
        (\m. {W : U}{v y : W}{w x : Pair A W -> W} -> Eq {A}
          (fst (m (Pair A W) (\p. pair (f (fst p)) (w p)) (pair a v)))
          (fst (m (Pair A W) (\p. pair (f (fst p)) (x p)) (pair a y))))
        (\{m} acc. cong f acc)
        refl;


-- Successor is injective

let predLeftInvSuc : {n : Nat}{ni : NatInd {n}} -> Eq {Nat} (pred (suc n)) n
    = \{n}{ni}. ni (\n. Eq {Nat} (pred (suc n)) n) (cong suc) refl;

let sucInj : {m n : Nat}{mi : NatInd {m}}{ni : NatInd {n}} -> Eq {Nat} (suc m) (suc n) -> Eq {Nat} m n
    = \{m}{n}{mi}{ni} sucEq.
        stepAs            m   (sym (predLeftInvSuc {m}{mi}))
       (stepAs (pred (suc m)) (cong pred sucEq)
       (stepAs (pred (suc n)) (predLeftInvSuc {n}{ni})
       (qed               n)));