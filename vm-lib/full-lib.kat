-- Void

let Void : U                                        = (V : U) -> V;
let absurd : {A} -> Void -> A                       = \V. _;


-- Unit

let Unit : U                                        = (T : U) -> T -> T;
let tt : Unit                                       = \T t. t;


-- Booleans

let Bit : U                                         = (B : U) -> B -> B -> B;
let I : Bit                                         = \B i o. i;
let O : Bit                                         = \B i o. o;
let not : Bit -> Bit                                = \b B i o. b B o i;
let and : Bit -> Bit -> Bit                         = \x y B i o. x B (y B i o) (x B i o);
let or : Bit -> Bit -> Bit                          = \x y B i o. x B (x B i o) (y B i o);
let xor : Bit -> Bit -> Bit                         = \x y B i o. x B (y B o i) (y B i o);
let if : {R} -> Bit -> R -> R -> R                  = \p a b. p _ a b;
let carry : Bit -> Bit -> Bit -> Bit                = \a b c. or (and a b) (and c (xor a b));
let sum : Bit -> Bit -> Bit -> Bit                  = \a b c. xor (xor a b) c;


-- Nats

let Nat : U                                         = (N : U) -> (N -> N) -> N -> N;
let zero : Nat                                      = \N s z. z;
let suc : Nat -> Nat                                = \n N s z. s (n N s z);
let add : Nat -> Nat -> Nat                         = \a b N s z. a N s (b N s z);
let mul : Nat -> Nat -> Nat                         = \a b N s z. a N (b N s) z;
let pred : Nat -> Nat                               = \n. snd {Nat} (n _ (\p. pair (suc (fst p)) (fst p)) (pair zero zero));
let minus : Nat -> Nat -> Nat                       = \m n. n _ pred m;
let eqz : Nat -> Bit                                = \n. n _ (\z B i o. o) (\B i o. i);

let foldnat : {A} -> (Nat -> A -> A) -> A -> Nat -> A
    = \{A} reducer base n. snd {Nat} (n (Pair Nat A) (\p. pair (suc (fst p)) (p A (\m. reducer (suc m)))) (pair zero base));
let fact : Nat -> Nat
    = \n. foldnat {Nat} (\k acc. mul acc k) (suc zero) n;
-- fact (suc (suc (suc zero)))


-- Identity

let Wrap : U -> U                                   = \A. (W : U) -> (A -> W) -> W;
let wrap : {A} -> A -> Wrap A                       = \a W w. w a;
let unwrap : {A} -> Wrap A -> A                     = \w. w _ (\x. x);


-- Products

let Pair : U -> U -> U                              = \A B. (P : U) -> (A -> B -> P) -> P;
let pair : {A B} -> A -> B -> Pair A B              = \a b P p. p a b;
let fst : {A B} -> Pair A B -> A                    = \s. s _ (\a b. a);
let snd : {A B} -> Pair A B -> B                    = \s. s _ (\a b. b);


-- Maybe

let Maybe : U -> U                                  = \A. (M : U) -> M -> (A -> M) -> M;
let nothing : {A} -> Maybe A                        = \M n j. n;
let just : {A} -> A -> Maybe A                      = \a M n j. j a;
let maybeFunctor : Functor Maybe                    = \F. F (\fn ma M n j. ma M n (\a. j (fn a)));
-- maybeFunctor (\map. map not (just O))


-- Either

let Either : U -> U -> U                            = \A B. (E : U) -> (A -> E) -> (B -> E) -> E;
let left : {A B} -> A -> Either A B                 = \a E l r. l a;
let right : {A B} -> B -> Either A B                = \b E l r. r b;


-- Lists

let List : U -> U                                   = \A. (L : U) -> L -> (A -> L -> L) -> L;
let nil  : {A} -> List A                            = \L n c. n;
let cons : {A} -> A -> List A -> List A             = \a as L n c. c a (as L n c);
let concat : {A} -> List A -> List A -> List A      = \{A} la lb. la (List A) lb cons;


-- Non-empty list

let Nonempty : U -> U                               = \A. {N} -> (A -> N) -> (A -> N -> N) -> N;
let sing : {A} -> A -> Nonempty A                   = \a s c. s a;
let cons : {A} -> A -> Nonempty A -> Nonempty A     = \a as s c. c a (as s c);


-- Continuations

let Cont : U -> U -> U                              = \W A. (C : U) -> (((A -> W) -> W) -> C) -> C;
let cont : {W A} -> ((A -> W) -> W) -> Cont W A     = \f C c. c f;
let run : {W A} -> Cont W A -> (A -> W) -> W        = \c f. c _ (\k. k f);
let reset : {W} -> Cont W W -> W                    = \m. run m (\x. x);
let shift : {W A} -> ((A -> W) -> Cont W W) -> Cont W A = \e. cont (\k. reset (e k));



-- Dependent Identity

let DWrap : {T} -> T -> U                           = \{T} t. (W : {T} -> T -> U) -> ({V} -> (v : V) -> W {V} v) -> W {T} t;
let dwrap : {T} -> (t : T) -> DWrap {T} t           = \{V} v W w. w {V} v;
let undwrap : {T t} -> DWrap {T} t -> T             = \{V}{v} w. w (\_. V) (\_. v);
-- tt (DWrap tt) ((\t. tt (DWrap {Unit} t) (dwrap t)) tt)


-- Dependent Nats

let DNat : {n} -> U                                   = \{n}. (DN : Nat -> U) -> ({m} -> DN m -> DN (suc m)) -> DN zero -> DN n;
let dz : DNat {zero}                                  = \DN s z. z;
let ds : {n} -> DNat {n} -> DNat {suc n}              = \n DN s z. s (n DN s z);
let initWord : {n} -> DNat {n} -> LTree {n} Bit       = \dn. dn (\n. LTree {n} Bit) (\acc. node acc acc) (leaf O);
-- initWord (ds (ds dz))


-- Finite Sets

let Fin : {n} -> U                                  = \{n}. (F : Nat -> U) -> ({m} -> F m -> F (suc m)) -> ({m} -> F (suc m)) -> F n;
let fz : {n} -> Fin {suc n}                         = \F s z. z;
let fs : {n} -> Fin {n} -> Fin {suc n}              = \f F s z. s (f F s z);

let foldfin : {A : Nat -> U}{n} ->
    ({m} -> Fin {suc m} -> A m -> A (suc m)) ->
    ({m} -> A (suc m)) -> Fin {suc n} -> A (suc n)
    = \{A}{n} reducer base fn. snd {Fin {suc n}} (fn
        (\n. Pair (Fin {n}) (A n))
        (\{m} p. pair (fs (fst p)) (p (A (suc m)) (\f. reducer {m} (fs f))))
        (\{m}. pair fz (base {m})));
-- foldfin {\_. Bit} (\fn acc. not acc) O (fs (fs fz))

-- Length-indexed Vectors

let Vec : {n} -> U -> U                             = \{n} A. (V : Nat -> U) -> V zero -> ({m} -> A -> V m -> V (suc m)) -> V n;
let nil : {A} -> Vec {zero} A                       = \V n c. n;
let cons : {A n} -> A -> Vec {n} A -> Vec {suc n} A = \a as V n c. c a (as V n c);
let head : {A n} -> Vec {suc n} A -> A              = \{A} v. v (\_. A) _ (\x xs. x);
let tail : {A n} -> Vec {suc n} A -> Vec {n} A      = \{A}{n} v. v (\_. Vec {n} A) _ (\x xs. xs);
-- tail (cons I (cons O nil))

let foldvec : {A}{B : Nat -> U}{n} ->
    ({m} -> Vec {suc m} A -> B m -> B (suc m)) ->
    B zero -> Vec {n} A -> B n
    = \{A}{B}{n} reducer base v. snd {Vec {n} A} (v
        (\n. Pair (Vec {n} A) (B n))
        (pair nil base)
        (\{m} a p. pair (cons a (fst p)) (p (B (suc m)) (\v. reducer {m} (cons a v)))));
-- foldvec {Bit}{\_. Bit} (\v acc. or acc (head v)) O (cons I (cons O nil))

-- Height-indexed Binary Leaf-only Trees

let LTree : {n} -> U -> U                           = \{n} A. (T : Nat -> U) -> (A -> T zero) -> ({m} -> T m -> T m -> T (suc m)) -> T n;
let leaf : {A} -> A -> LTree {zero} A               = \a T l n. l a;
let node : {A n} -> LTree {n} A -> LTree {n} A -> LTree {suc n} A = \ta tb T l n. n (ta T l n) (tb T l n);
let divine : {A} -> LTree {zero} A -> A             = \{A} t. t (\_. A) (\a. a) _;
let lbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. ta);
let rbranch : {A n} -> LTree {suc n} A -> LTree {n} A = \{A}{n} t. t (\_. LTree {n} A) _ (\ta tb. tb);
-- divine (leaf O)
-- lbranch (node (leaf O) (leaf I))

let ltreeFunctor : Functor LTree                     = \F. F (\fn ta T l n. ta T (\a. l (fn a)) n);
-- ltreeFunctor (\map. map not (initWord (ds (ds dz))))


-- Bush
-- Reference: Dependently Typed Folds for Nested Data Types, Peng Fu and Peter Selinger

let Bush : {n} -> U -> U
    = \{n} A. (B : Nat -> U) -> (A -> B zero) -> ({n} -> B (suc n)) ->
        ({n} -> B n -> B (suc (suc n)) -> B (suc n)) -> B n;
let bbase : {A} -> A -> Bush {zero} A               = \a B b n c. b a;
let bnil : {n A} -> Bush {suc n} A                  = \B b n c. n;
let bcons : {n A} -> Bush {n} A -> Bush {suc (suc n)} A -> Bush {suc n} A
    = \x xs B b n c. c (x B b n c) (xs B b n c);
let mapbush : {A B n} -> (A -> B) -> Bush {n} A -> Bush {n} B
    = \{A}{B} fn bush. bush (\n. Bush {n} B) (\x. bbase (fn x)) bnil bcons;

-- [ O,
--   [ I, [ I ] ],
--   [ [ O ] ] ]
let somebush : Bush Bit
    = bcons (bbase O) (bcons
            (bcons (bbase I) (bcons
                   (bcons (bbase I) bnil)
                   bnil)) (bcons
            (bcons (bcons (bbase O) bnil)
                   bnil)
            bnil));
            
-- mapbush not somebush


-- Nullary Relations

let neg : U -> U                                    = \P. P -> Void;
let contradiction : {P Q} -> P -> neg P -> Q        = \p notp. absurd (notp p);

let Reflects : U -> Bit -> U                          = \P b. (R : Bit -> U) -> (P -> R I) -> (neg P -> R O) -> R b;
let ofyes : {P} -> P -> Reflects P I                  = \p R y n. y p;
let ofno : {P} -> neg P -> Reflects P O               = \negp R y n. n negp;

let Dec : U -> U                                    = \P. Either P (neg P);
let Decidable : {A B} -> (A -> B -> U) -> U         = \{A}{B} p. (x : A) -> (y : B) -> Dec (p x y);


-- Monoid

let Monoid : U -> U                                 = \(M : U). ((neut : M) -> (comb : {A} -> A -> M -> M) -> M) -> M;
let maybeMonoid : {A} -> Monoid (Maybe A)           = \{Z} M. M nothing (\{Y} a _. just {Y} a);
-- maybeMonoid {Bit} (\neut comb. comb I neut)


-- Functors

let Functor : (U -> U) -> U
    = \(F : U -> U). {T} -> ((map : {A B} -> (A -> B) -> F A -> F B) -> F T) -> F T;
let listFunctor : Functor List                      = \F. F (\fn la L n c. la L n (\a as. c (fn a) as));
-- listFunctor (\map. map not (cons O (cons I nil)))


-- Applicatives

let App : (U -> U) -> U
    = \(F : U -> U). {T} -> ((pure : {A} -> A -> F A) ->
        (ap : {A B} -> F (A -> B) -> F A -> F B) -> F T) -> F T;
let appFunctor : {F} -> App F -> Functor F          = \app F. F (\{A}{B} fn fa. app (\pure ap. ap {A}{B} (pure fn) fa));
let listApp : App List                              = \A. A (\x. cons x nil) (\fs xs. fs _ nil (\f bs. concat (listFunctor (\map. map f xs)) bs));
-- listApp (\pure ap. ap (cons not (cons (\x. x) nil)) (cons O (cons I nil)))

let appComp : {F G : U -> U} -> App F -> App G -> App (\X. F (G X))
    = \{F}{G} appF appG A. A
        (\{X} fgx. appF {G X} (\pureF apF. pureF (appG {X} (\pureG apG. pureG fgx))))
        (\{X}{Y} fgf fgx. appF (\pureF apF. apF (apF {G (X -> Y)}{G X -> G Y}
            (pureF (\gf gx. appG (\pureG apG. apG gf gx))) fgf) fgx));
-- (appComp listApp listApp) (\pure ap. ap
--     (cons (cons not nil) (cons (cons (\x. x) nil) nil))
--     (cons (cons O (cons I nil)) (cons (cons I nil) nil)))


-- Monads

let Monad : (U -> U) -> U
    = \(F : U -> U). {T} -> ((return : {A} -> A -> F A) ->
        (bind : {A B} -> F A -> (A -> F B) -> F B) -> F T) -> F T;
let contMonad : {W} -> Monad (Cont W)               = \F. F (\x. cont (\k. k x)) (\m f. cont (\k. run m (\v. run (f v) k)));

let mapM : {A B}{M : U -> U}{monad : Monad M} -> (A -> M B) -> List A -> M (List B)
    = (\{A}{B}{M}{monad} f as. monad
        (\return bind. as (M (List B)) (return nil)
            (\a r. bind {B}{List B} (f a) (\x. bind {List B}{List B} r (\xs. return (cons x xs))))));
-- run {List Bit} (mapM {monad=contMonad} (\b. cont (\k. k (not b))) (cons I (cons O nil))) (\x. x)


-- Traversable

let Trav : (U -> U) -> U
    = \(F : U -> U). {T} -> ((traverse : {G : U -> U}{A B}{app : App G} -> (A -> G B) -> F A -> G (F B)) -> F T) -> F T;